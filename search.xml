<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Spring3.X学习笔记5-SpringAOP基础]]></title>
    <url>%2F2017%2F11%2F22%2FSpring3.X%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B05-SpringAOP%E5%9F%BA%E7%A1%80%2F</url>
    <content type="text"><![CDATA[Spring AOP是AOP技术在Spring中的具体实现，Spring AOP构建于IoC之上，和IoC一同构成了Spring的两大核心。 AOP概述AOP（Aspect Oriented Programming），即面向切面编程，可以说是OOP（Object Oriented Programming，面向对象编程）的补充和完善。OOP引入封装、继承、多态等概念来建立一种对象层次结构，用于模拟公共行为的一个集合。不过OOP允许开发者定义纵向的关系，但并不适合定义横向的关系，例如日志功能。日志代码往往横向地散布在所有对象层次中，而与它对应的对象的核心功能毫无关系。对于其它类型的代码，如安全性、异常处理和透明的持续性也都是如此，这种散布在各处的无关的代码被称为横切（cross cutting），在OOP设计中，它导致了大量代码的重复，而不利于各个模块的重用。 AOP技术恰恰相反，它利用一种称为”横切”的技术，剖解开封装的对象内部，并将那些影响了多个类的公共行为封装到一个可重用模块，并将其命名为”Aspect”，即切面。所谓”切面”，简单说就是那些与业务无关，却为业务模块所共同调用的逻辑或责任封装起来，便于减少系统的重复代码，降低模块之间的耦合度，并有利于未来的可操作性和可维护性。使用”横切”技术，AOP把软件系统分为两个部分：核心关注点和横切关注点。业务处理的主要流程是核心关注点，与之关系不大的部分是横切关注点。横切关注点的一个特点是，他们经常发生在核心关注点的多处，而各处基本相似，比如权限认证、日志、事物。AOP的作用在于分离系统中的各种关注点，将核心关注点和横切关注点分离开来。 AOP基础概念学习一个新事物首先就要了解其基本概念和关键术语，为了更好的理解AOP思想，下面先来看下有关AOP的重要概念： 连接点（Joinpoint）：被拦截到的点，因为Spring只支持方法类型的连接点，所以在Spring中连接点指的就是被拦截到的方法，实际上连接点还可以是字段或者构造器。连接点有两个信息确定：第一是方法表示的程序执行点；第二是相对点表示的方位。Spring使用切点对执行点进行定位，而方位在增强类型中定义。 切点（Pointcut）：对连接点进行拦截的定义，AOP通过“切点”定位特定连接点，一个切点可以匹配多个连接点。 增强（Advice）：指拦截到连接点之后要执行的代码，还包括方位信息，结合这个方位信息和上面的切点就可以定位到特定的连接点了。通知分为前置（BeforeAdvice）、后置（AfterRetuningAdvice）、异常（ThrowsAdvice）、最终、环绕通知五类。 目标对象（Target）：增强逻辑的织入目标类。 引介（Introduction）：在不修改代码的前提下，引介可以在运行期为类动态地添加一些方法或字段。 织入（Weaving）：织入是将增强添加到目标类具体连接点上的过程。根据不同的实现技术，AOP有三种织入的方式: 编译期织入，这要求使用特殊的Java编译器； 类装载期织入，这要求使用特殊的类装载器； 动态代理织入，在运行期为目标类添加增强生成子类的方式。 代理（Proxy）：一个类被AOP织入增强后，就生成了一个融合原类和增强逻辑的代理类。代理类可能是和原类具有相同接口的类，也可能就是原类的子类，所以我们可以采用调用原类相同的方式调用代理类。 切面（Aspect）：切面是横切关注点的抽象。它由切点和增强(引介)组成，它既包括了横切逻辑的定义，也包括连接点的定义，Spring AOP就是负责实施切面的框架，它将切面所定义的横切逻辑织入到切面所指定的连接点中。 提示：Spring采用动态代理织入，而Aspectj采用编译器织入和类装载器织入。 1.2 基础知识Spring AOP使用动态代理技术在运行期织入增强的代码，包括两种代理机制，一种是基于JDk的动态代理；另一种是基于CGLib的动态代理。下面先看一个未使用动态代理的例子：12345678910111213141516171819202122232425262728293031package com.hhxs.bbt.proxy;public class ForumServiceImpl implements ForumService &#123; @SuppressWarnings("static-access") @Override public void removeTopic(int topicId) &#123; // 性能监视开始 PerformanceMonitor.begin("com.hhxs.proxy.ForumServiceImpl.removeTopic"); System.out.println("模拟删除Topic记录:" + topicId); try &#123; Thread.currentThread().sleep(20); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; // 性能监视结束 PerformanceMonitor.end(); &#125; @SuppressWarnings("static-access") @Override public void removeForum(int forumId) &#123; PerformanceMonitor.begin("com.hhxs.proxy.ForumServiceImpl.removeForum"); System.out.println("模拟删除Forum记录:" + forumId); try &#123; Thread.currentThread().sleep(40); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; PerformanceMonitor.end(); &#125;&#125; 1234567891011121314151617181920package com.hhxs.bbt.proxy;public class PerformanceMonitor &#123; // 通过一个ThreadLocal保存调用线程相关的性能监视信息 private static ThreadLocal&lt;MethodPerformance&gt; performanceRecord = new ThreadLocal&lt;MethodPerformance&gt;(); // 启动对某一目标方法的性能监视 public static void begin(String method) &#123; System.out.println("begin monitor..."); MethodPerformance mp = new MethodPerformance(method); performanceRecord.set(mp); &#125; public static void end() &#123; System.out.println("end monitor..."); MethodPerformance mp = performanceRecord.get(); mp.printPerformance(); &#125;&#125; 123456789101112131415161718package com.hhxs.bbt.proxy;public class MethodPerformance &#123; private long begin; private long end; private String serviceMethod; public MethodPerformance(String serviceMethod) &#123; this.serviceMethod = serviceMethod; this.begin = System.currentTimeMillis(); &#125; public void printPerformance() &#123; end = System.currentTimeMillis(); long elapse = end - begin; System.out.println(serviceMethod + "花费" + elapse + "毫秒。"); &#125;&#125; 1234567891011package com.iflytek.bbt.proxy;import com.hhxs.bbt.proxy.ForumService;import com.hhxs.bbt.proxy.ForumServiceImpl;public class TestForumService &#123; public static void main(String[] args) &#123; ForumService forumService = new ForumServiceImpl(); forumService.removeForum(10); forumService.removeTopic(1012); &#125;&#125; 运行结果如下：12345678begin monitor...模拟删除Forum记录:10end monitor...com.hhxs.proxy.ForumServiceImpl.removeForum花费46毫秒。begin monitor...模拟删除Topic记录:1012end monitor...com.hhxs.proxy.ForumServiceImpl.removeTopic花费21毫秒。 正如上述代码所示，当某个方法需要进行性能监视，就必须调整方法代码，在方法前后分别添加上开启性能监视和结束性能监视的代码。我们希望通过代理的方式，将业务类方法中开启和结束性能监视的这些横切代码从业务类中完全剥离出来。并通过JDK动态代理技术或CGLib动态代理技术将横切代码织入到目标方法的相应位置。 JDK动态代理JDK的动态代理主要涉及到java.lang.reflect包中的两个类：Proxy和InvocationHandler。其中InvocationHandler，通过实现该接口定义横切逻辑。而Proxy利用InvocationHandler动态创建一个符合某一接口的实例，生成目标类的代理对象。 12345678910111213141516171819202122232425package com.hhxs.bbt.proxy;public class ForumServiceImpl implements ForumService &#123; @SuppressWarnings("static-access") @Override public void removeTopic(int topicId) &#123; System.out.println("模拟删除Topic记录:" + topicId); try &#123; Thread.currentThread().sleep(20); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; @SuppressWarnings("static-access") @Override public void removeForum(int forumId) &#123; System.out.println("模拟删除Forum记录:" + forumId); try &#123; Thread.currentThread().sleep(40); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125;&#125; 123456789101112131415161718package com.hhxs.bbt.proxy;import java.lang.reflect.InvocationHandler;import java.lang.reflect.Method;public class PerformanceHandler implements InvocationHandler &#123; private Object target; public PerformanceHandler(Object target) &#123; this.target = target; &#125; @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123; PerformanceMonitor.begin(target.getClass().getName()+"."+method.getName()); Object obj = method.invoke(target, args); PerformanceMonitor.end(); return obj; &#125;&#125; 首先，我们实现了InvocationHandler接口，该接口定义了一个invode(Object proxy,Method method,Object[] args)的方法。其中，method是被代理目标实例的某个具体方法，通过它可以发起目标实例方法的反射调用；args是传给被代理实例某一个方法的入参数组，在方法反射调用时使用。此外，我们在构造函数里通过target传入希望被代理的目标对象，在InvocationHandler接口方法invoke(Object proxy,Method method,Object[] args)里，将目标实例传给method.invoke()方法，调用目标实例的方法。 123456789101112131415161718192021package com.iflytek.bbt.proxy;import java.lang.reflect.Proxy;import com.hhxs.bbt.proxy.ForumService;import com.hhxs.bbt.proxy.ForumServiceImpl;import com.hhxs.bbt.proxy.PerformanceHandler;public class TestForumService &#123; public static void main(String[] args) &#123; // 希望被代理的目标业务类 ForumService target = new ForumServiceImpl(); // 将目标业务类和横切代码编织到一起 PerformanceHandler handler = new PerformanceHandler(target); // 根据编织了目标业务类逻辑和性能监视横切逻辑的InvocationHandler实例创建代理实例 ForumService proxy = (ForumService) Proxy.newProxyInstance(target.getClass().getClassLoader(), target.getClass().getInterfaces(), handler); proxy.removeForum(10); proxy.removeTopic(1012); &#125;&#125; 上面的代码完成业务类代码和横切代码的编织工作并生成了代理实例。运行以上代码，输出结果：12345678begin monitor...模拟删除Forum记录:10end monitor...com.hhxs.bbt.proxy.ForumServiceImpl.removeForum花费42毫秒。begin monitor...模拟删除Topic记录:1012end monitor...com.hhxs.bbt.proxy.ForumServiceImpl.removeTopic花费25毫秒。 CGLib动态代理通过上面的实例可以看出，使用JDK创建代理有一个限制，即它只能为接口创建代理实例。对于没有通过接口定义业务方法的类，JDK的代理技术就无法处理了，而CGLib采用非常底层的字节码技术，通过创建一个子类，并在子类中采用方法拦截所有父类方法的调用，并顺势织入横切逻辑。下面采用CGLib技术改造上面的例子：1234567891011121314151617181920212223package com.hhxs.bbt.proxy;import java.lang.reflect.Method;import net.sf.cglib.proxy.Enhancer;import net.sf.cglib.proxy.MethodInterceptor;import net.sf.cglib.proxy.MethodProxy;public class CglibProxy implements MethodInterceptor &#123; private Enhancer enhancer = new Enhancer(); public Object getProxy(Class&lt;?&gt; clazz) &#123; enhancer.setSuperclass(clazz); enhancer.setCallback(this); // 通过字节码技术动态创建子类实例 return enhancer.create(); &#125; @Override public Object intercept(Object obj, Method method, Object[] args, MethodProxy proxy) throws Throwable &#123; PerformanceMonitor.begin(obj.getClass().getName()+"."+method.getName()); Object result = proxy.invokeSuper(obj, args); PerformanceMonitor.end(); return result; &#125;&#125; 上述代码中，intercept(Object obj,Method method,Object[] args,MethodProxy proxy)是CGLib定义Interceptor接口的方法，它拦截所有目标类方法的调用，obj表示目标类的实例：method为目标类方法的反射对象；args为方法的动态入参；而proxy为代理类实例。12345678910111213package com.iflytek.bbt.proxy;import com.hhxs.bbt.proxy.CglibProxy;import com.hhxs.bbt.proxy.ForumServiceImpl;public class TestForumService &#123; public static void main(String[] args) &#123; CglibProxy proxy = new CglibProxy(); ForumServiceImpl forumService = (ForumServiceImpl) proxy.getProxy(ForumServiceImpl.class); forumService.removeForum(10); forumService.removeTopic(1024); &#125;&#125; 运行以上代码，输出结果：12345678begin monitor...模拟删除Forum记录:10end monitor...com.hhxs.bbt.proxy.ForumServiceImpl$$EnhancerByCGLIB$$5f4be940.removeForum花费62毫秒。begin monitor...模拟删除Topic记录:1024end monitor...com.hhxs.bbt.proxy.ForumServiceImpl$$EnhancerByCGLIB$$5f4be940.removeTopic花费24毫秒。 代理知识小结上述例子中，我们虽然通过PerformanceHandler或CglibProxy实现了性能监视横切逻辑的动态织入，但这种实现方式存在三个明显需要改进的地方： 目标类的所有方法都添加了性能监视横切逻辑，而有时，我们可能只是希望对业务类中的某些特定方法添加横切逻辑。 我们通过硬编码的方式指定的织入横切逻辑的切入点。 需要手工编写代理实例的创建过程，为不同类创建代理时，需要分别编写相应程序代码，无法做到通用。 以上三个问题，在AOP中占有重要的地位，Spring AOP的主要工作就是围绕以上三点展开：Spring AOP通过Pointcut（切点）指定在哪些类的哪些方法上织入横切逻辑，通过Advice（增强）描述横切逻辑和方法的具体织入点。此外，Spring通过Advisor（切面）将Pointcut和Advice两者组装起来。有了Advisor的信息，Spring就可以利用JDK或CGLib的动态代理技术采用统一的方式为目标Bean创建织入切面的代理对象了。值得一提的是，由于CGLib动态创建子类的方式生成代理对象，所以不能对目标类中的final，private等方法进行代理。]]></content>
      <categories>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>AOP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring3.X学习笔记4-Spring容器高级主题]]></title>
    <url>%2F2017%2F11%2F15%2FSpring3.X%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B04-Spring%E5%AE%B9%E5%99%A8%E9%AB%98%E7%BA%A7%E4%B8%BB%E9%A2%98%2F</url>
    <content type="text"><![CDATA[Spring容器是一部设计精妙的机器，其优异的外在表现是通过精细的内部设计实现的。本篇将对Spring容器进行解构，从内部探究Spring容器的体系结构和运行流程。 1、Spring容器技术内幕1.1 内部工作机制下图描述了Spring容器从加载配置文件到创建出一个完整Bean的作业流程以及参与的角色： ResourceLoader从存储介质中接收Spring配置文件，并使用Resource表示这个配置文件的资源； BeanDefinitionReader读取Resource所指向的配置文件资源，然后解析配置文件。配置文件中每一个&lt;bean&gt;解析成一个BeanDefinition对象，并保存到BeanDefinitionRegistery中； 容器扫描BeanDefinitionRegistery中的BeanDefinition，使用Java的反射机制自动识别出Bean工厂后处理器（实现BeanFactoryPostProcessor接口）的Bean，然后调用这些Bean工厂后处理器对BeanDefinitionRegistery中的BeanDefinition进行加工处理。主要完成以下两项工作： 对使用到占位符的&lt;bean&gt;元素标签进行解析，得到最终的配置值，这意味对一些半成品的BeanDefinition对象进行加工处理并得到成品的BeanDefinition对象； 对BeanDefinitionRegistery中的BeanDefinition进行扫描，通过Java反射机制找出所有属性编辑器的Bean(实现java.beans.PropertyEditor接口的Bean) ，并自动将它们注册到Spring容器的属性编辑器注册表中（PropertyEditorRegistry）； Spring容器从BeanDefinitionRegistery中取出加工后的BeanDefinition，并调用InstantiationStrategy着手进行Bean实例化的工作； 在实例化Bean时，Spring容器使用BeanWrapper对Bean进行封装，BeanWrapper提供了很多以Java反射机制操作Bean的方法，它将结合该Bean的BeanDefinition以及容器中属性编辑器，完成Bean属性的设置工作； 利用容器中注册的Bean后处理器（实现BeanPostProcessor接口的Bean）对已经完成属性设置工作的Bean进行后续加工，直接装配出一个准备就绪的Bean。 Spring组件按其所承担的角色可以划分为两类： 物料组件：Resource、BeanDefinition、PropertyEditor以及最终的Bean等，它们是加工流程中被加工、被消费的组件，就像流水线上被加工的物料； 加工设备组件：Resourceloader、BeanDefinitionReader、BeanFactoryPostProcessor、InstantiationStrategy以及BeanWrapper等组件像是流水线上不同环节的加工设备，对物料组件尽心国家公处理。 1.2 BeanDefinitionorg.springframework.beans.factory.config.BeanDefinition是配置文件&lt;bean&gt;元素标签的在容器中的内在表示。 RootBeanDefinition是最常用的实现类，它对应一般性的&lt;bean&gt;元素标签。如果有父子关系，父&lt;bean&gt;用RootBeanDefinition表示，子&lt;bean&gt;用ChildBeanDefinition表示，若没有父子关系，&lt;bean&gt;就使用RootBeanDefinition表示。 一般情况下，BeanDefinition只在容器启动时加载并解析，除非容器刷新或重启，这些信息不会发生变化。 1.3 InstantiationStrategyorg.springframework.beans.factory.support.InstantiationStrategy负责根据BeanDefinition对象创建一个Bean实例。之所以将实例化Bean的工作通过一个策略接口进行描述，是为了方便可以采用不同的实例化策略，以满足不同的应用需求。 SimpleInstantiationStrategy策略利用Bean实现类的默认构造函数、带参构造函数或工厂方法创建Bean的实例。CglibSubclassingInstantiationStrategy利用CGLib类库为Bean动态生成子类，在子类中生成方法注入逻辑，然后用这个子类创建Bean实例。 InstantiationStrategy仅负责实例化Bean的操作，它并不会参与Bean属性的设置工作。属性填充的工作将由下面的BeanWrapper来完成。 1.4 BeanWrapperorg.springframework.beans.BeanWrapper是Spring容器中重要的组件类。BeanWrapper相当于一个代理器，Spring通过BeanWrapper完成Bean属性的填充工作。 PropertyAccessor接口定义了各种访问Bean属性的方法，而PropertyEditorRegistry是属性编辑器的注册表。所以BeanWrapper实现类BeanWrapperImpl具有了三重身份： Bean包裹器 属性访问器 属性编辑器注册表 2、属性编辑器任何实现java.beans.PropertyEditor接口的类都是属性编辑器。属性编辑器的主要功能就是将外部的设置值，转换为JVM内部的对应类型，所以属性编辑器其实就是一个类型转换器。 2.1 JavaBean的编辑器JavaBean规范通过java.beans.PropertyEditor定义了设置JavaBean属性的方法，通过BeanInfo描述了JavaBean哪些属性是可定制的，此外还描述了可定制属性与PropertyEditor的对应关系。 BeanInfo与JavaBean之间的对应关系，通过两者之间规范的命名确立：对应JavaBean的BeanInfo采用如下的命名规范：&lt;Bean&gt;BeanInfo。如ChartBean对应的BeanInfo为ChartBeanBeanInfo。 JavaBean规范还提供了一个管理默认属性编辑器的管理器：PropertyEditorManager，该管理器内保存着一些常见类型的属性编辑器，如果某个JavaBean的常见类型属性没有通过BeanInfo显示指定属性编辑器，IDE将自动使用PropertyEditorManager中注册的对应默认属性编辑器。 PropertyEditor是属性编辑器的接口，它规定了将外部设置值转换为内部JavaBean属性值的转换接口方法。PropertyEditor主要的接口方法说明如下： Object getValues()：返回属性的当前值。基本类型被封装成对应的封装类实例； void setValue(Object newValue)：设置属性的值，基本类型以封装类传入； String getAsText()：将属性对象用一个字符串表示，以便外部的属性编辑器能以可视化方式显示。缺省返回null，表示该属性不能以字符串表示； void setAsText(String text)：用一个字符串去更新属性的内部值，这个字符串一般从外部属性编辑器传入； String[] getTags()：返回表示有效属性值的字符串数组，以便属性编辑器能以下拉框的方式显示出来。缺省返回null，表示该属性没有匹配的字符值有限集合。 String getJavaInitializationString()：为属性提供一个表示初始值的字符串，属性编辑器以此值作为属性的默认值。 BeanInfo主要描述了哪些属性可以编辑以及对应的属性编辑器，每一个属性对应一个属性描述器PropertyDescriptor。BeanInfo接口最重要的方法就是：PropertyDescriptor[] getPropertyDescriptors()，该方法返回JavaBean的属性描述器数组。 2.2 Spring默认属性编辑器Spring环境下的属性编辑器功能非常单一，仅需要将配置文件中字面值转换为属性类型的对象即可，并不需要提供UI界面，Spring为常见的属性类型提供了默认的属性编辑器。如下表所示： 类别 说明 基础数据类型 分为几个小类：1) 基本数据类型，如：boolean、byte、short、int等；2) 基本数据类型封装类：如：Long、Character、Integer等；3) 两个基本数据类型的数组，char[]和byte[]；4) 大数类，BigDecimal和BigInteger 集合类 为5种类型的集合类Collection、Set、SortedSet、List和SortedMap提供了编辑器 资源类 用于访问外部资源的8个常见类Class、Class[]、File、InputSteam、Locale、Properties、Resource[]和URL。 这些默认的属性编辑器解决常见属性类型的注册问题，如果用户的应用包括一些特殊类型的属性，且希望在配置文件中以字面值提供配置值，那么就需要编写自定义属性编辑器并注册到Spring容器中。（在Spring环境下自定义属性编辑器仅需要覆盖PropertyEditorSupport的setAsText()方法就可以了。）下面看一代码片段：我们现在希望在配置Boss时，不通过引用Bean的方式注入Boss的car属性，而希望直接通过字符串字面值提供配置。 12345678910111213141516171819202122232425262728293031323334353637// Car类public class Car &#123; private int maxSpeed; public String brand; pirvate double price; // 省略get/setter方法&#125;// Boss类public class Boss &#123; private String name; private Car car = new Car(); // 省略get/setter&#125;// Car自定义属性编辑器import java.beans.PropertyEditorSupportpublic class CustomCarEditor extends PropertyEditorSupport &#123; // 1.将字面值转换为属性类型对象 public void setAsText(String text) &#123; if(text == null || text.indexOf(",") == 1) &#123; throw new IllegalArgumentException("设置的字符串格式不正确"); &#125; String[] infos = text.split(","); Car car = new Car(); car.setBrand(infos[0]); car.setMaxSpeed(Integer.parseInt(infos[1])); car.setPrice(Double.parseDouble(infos[2])); // 2.调用父类的setValue()方法设置转换后的属性对象 setValue(car); &#125;&#125; 注册自定义属性编辑器：如果使用BeanFactory，用户需要手工调用registerCustomEditor(Class requiredType，PropertyEditor propertyEditor)方法注册自定义属性编辑器；如果使用ApplicationContext，则只需要在配置文件通过CustomEditorConfigurer注册即可。CustomEditorConfigurer实现BeanFactoryPostProcessor接口，因此是一个Bean工厂后处理器。 123456789101112131415161718&lt;!-- 1.配置自动注册属性编辑器的CustomEditorConfigurer --&gt;&lt;bean class="org.springframework.beans.factory.config.CustomEditorConfigurer"&gt; &lt;property name="customEditors"&gt; &lt;map&gt; &lt;!-- 2.1 属性编辑器对应的属性类型--&gt; &lt;entry key="com.hhxs.editor.Car"&gt; &lt;!-- 2.2 对应的属性编辑器Bean--&gt; &lt;bean class="com.hhxs.editor。CustomCarEditor"/&gt; &lt;/entry&gt; &lt;/map&gt; &lt;/property&gt;&lt;/bean&gt;&lt;bean&gt; &lt;property name="name" value=“John”/&gt; &lt;!-- 3.该属性将使用2处的属性编辑器完成属性填充操作 --&gt; &lt;property name="car" value="红旗CA72,200,20000.00"/&gt;&lt;/bean&gt; 提示： 按照JavaBeans的规范，JavaBeans的基础设施会在JavaBean相同类包下查找是否存在&lt;JavaBean&gt;Editor的类，如果存在，自动使用&lt;JavaBean&gt;Editor作为该JavaBean的PropertyEditor。Spring也支持这个规范，这样就无需显示在CustomEditorConfigurer中注册了。 3、使用外部属性文件在进行数据源以及文件服务器等资源配置时，我们可以直接在Spring配置文件中配置，但是这样会存在一个问题就是一旦相应的资源环境变了，我们就要去更改配置文件，这会增加我们的部署复杂度，增加维护工作量。还有一种更好的方式，是将这些经常变动的的配置信息独立到一个外部属性文件中，并在Spring配置文件中通过形如${user}、${password}等占位符引用属性文件中的属性项。 下面看一个配置数据源的例子： 123456789101112131415161718// jdbc.properties文件driverClassName=com.mysql.jdbc.Driver url=jdbc:mysql://localhost:3306/testuserName=rootpassword=1234// Spring配置文件代码片段&lt;!-- 1.引入jdbc.properties属性文件 --&gt;&lt;bean class="org.springframework.beans.factory.config.PropertyPlaceholderConfigurer" p:location="classpath:com/hhxs/placeholder/jdbc.properties" p:fileEncoding="utf-8"/&gt;&lt;!-- 2.通过属性名引用属性值 --&gt;&lt;bean id="dataSource" class=”org.apache。commons.dbcp.BasicDataSource” destroy-method="close" p:driverClassName="$&#123;driverClassName&#125;" p:url="$&#123;url&#125;" p:username="$&#123;userName&#125;" p:password="$&#123;password&#125;" /&gt; PropertyPlaceholderConfigurer其他属性 locations：如果只有一个属性文件，直接使用location属性指定就可以了，如果是多个属性文件，则可以通过locations属性进行设置，可以像配置List一样配置locations属性。 1234567&lt;property name="locations"&gt; &lt;list&gt; &lt;value&gt;jdbc1.properties/value&gt; &lt;value&gt;jdbc2.properties &lt;/value&gt; &lt;value&gt;jdbc3.properties&lt;/value&gt; &lt;/list&gt;&lt;/property&gt; fileEncoding： 属性文件的编码格式，Spring使用操作系统默认编码读取属性文件，如果属性文件采用了特殊编码，需要通过该属性显示指定。 order：如果配置文件中定义了多个PropertyPlaceHolderConfigurer，则通过该属性指定优先顺序。 placeholderPrefix：在上面的例子中，我们通过${属性名}引用属性文件中的属性项，其中”${“为默认的占位符前缀，可以根据需要改为其他的前缀符。 placeholderSuffix：占位符后缀，默认为”}”。 使用&lt;context:property-placeholder&gt;引用属性文件可以使用context命名空间定义属性文件，例如：1&lt;context:property-placeholder location="classpath:com/hhxs/bbt/placeholder/jdbc.properties"/&gt; 基于注解及基于Java类配置中引用属性基于注解配置的Bean可以通过@Value的注解为Bean的成员变量或方法入参自动注入容器已有的属性。如下所示：12345678910111213141516171819202122import org.springframework.beans.factory.annotation.Value;import org.springframework.stereotype.Component;@Componentpublic class MyDataSource &#123; @Value("$&#123;driverClassName&#125;") private String driverClassName; @Value("$&#123;url&#125;") private String url; @Value("$&#123;userName&#125;") private String userName; @Value("$&#123;password&#125;") private String password; public String toString() &#123; return ToStringBuilder.reflectionToString(this); &#125;&#125; 由于标注@Configuration的类本身相当于标注@Component，所以在标注@Configuration类中引用属性的方式和基于注解配置的引用方式是完全一样的。 5、容器事件Spring的ApplicationContext能够发布事件并且允许注册相应的事件监听器。Java中通过java.util.EventObject类和java.util.EventListener接口描述事件和监听器，某个组件或框架要建立自己的事件发布和监听机制，一般都通过扩展它们进行定义。在事件体系中，除了事件和监听器以外，还有另外三个重要的概念： 事件源：事件的生产者，任何一个EventObject都必须拥有一个事件源； 事件监听注册表：一个事件监听器注册到组件或框架中，其实就是保存在监听器注册表里，当组件和框架中的事件源产生事件时就会将事件通知这些位于注册表中的监听器； 事件广播器：负责把事件通知给事件监听器。 图片 事件体系角色 5.1 Spring事件类结构 事件类 ApplicationEvent的唯一构造函数是ApplicationEvent(Object source)，通过Source指定事件源，它的两个子类分别是： ApplicationContextEvent：容器事件，拥有4个子类分别表示容器启动、刷新、停止及关闭的时间； RequestHandleEvent：这是一个与Web应用相关的事件，当一个HTTP请求被处理后，产生该事件。只有在web.xml中定义了DispatcherServlet时才会产生该事件。 事件监听器接口 ApplicationListener接口之定义了一个方法：onApplicationEvent(E event)，该方法接受ApplicationEvent事件对象，在该方法中编写事件的响应处理逻辑。SmartApplicationListener接口是Spring3.0新增的，它定义了两个方法： boolean supportsEventType(Class&lt;? extends ApplicationEvent&gt; eventType)：指定监听器支持哪种类型的容器事件，即它只会对该类型的事件作出响应； boolean supportsSourceType(Class&lt;?&gt; sourceType)：该方法指定监听器仅对何种事件源对象作出响应。 事件广播器当发生容器事件时，容器主控程序将调用事件广播器将事件通知注册给注册表中的事件监听器。Spring为事件广播器定义了接口，并提供了实现类，如图： 5.2 解构Spring时间体系的具体实现Spring在ApplicationContext接口的抽象实现类AbstractApplicationContext中完成了事件体系的搭建。AbstractApplicationContext拥有一个applicationEventMulticaster成员变量，applicationEventMulticaster提供了容器监听器的注册表。AbstractApplicationContext在refresh()这个容器启动方法中通过以下三个步骤搭建了事件的基础设施，代码片段如下：12345678910...// 1 初始化应用上下文事件广播器initApplicationEventMulticaster();// 2 注册事件监听器registerListeners();// 3 完成刷新并发布容器刷新事件finishRefresh();... 1处，Spring初始化事件的广播器。用户可以在配置文件中为容器定义一个自定义的事件广播器，Spring会通过反射的机制将其注册成容器的事件广播器。如果没有找到配置的外部事件广播器，Spring自动使用SimpleApplicationEventMulticaster作为事件广播器。2处，Spring将根据反射机制，从BeanDefinitionRegistry中找出所有实现ApplicationListener的Bean，将它们注册为容器的事件监听器。3处，容器启动完成，调用事件发布接口向容器中所有的监听器发布事件。 下面看一个例子，一个模拟的邮件发送器。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889// MailSendEvent类package com.hhxs.bbt.event;import org.springframework.beans.BeansException;import org.springframework.context.ApplicationContext;import org.springframework.context.ApplicationContextAware;public class MailSender implements ApplicationContextAware &#123; private ApplicationContext ctx; @Override public void setApplicationContext(ApplicationContext ctx) throws BeansException &#123; this.ctx = ctx; &#125; public void sendMail(String to) &#123; System.out.println("MailSender：模拟发送邮件..."); MailSendEvent mse = new MailSendEvent(this.ctx, to); ctx.publishEvent(mse); &#125;&#125;// MailSendListener类package com.hhxs.bbt.event;import org.springframework.context.ApplicationListener;public class MailSendListener implements ApplicationListener&lt;MailSendEvent&gt; &#123; @Override public void onApplicationEvent(MailSendEvent event) &#123; MailSendEvent mse = (MailSendEvent) event; System.out.println("MailSendListener：向" + mse.getTo() + "发送完一封邮件"); &#125;&#125;// MailSender类package com.hhxs.bbt.event;import org.springframework.beans.BeansException;import org.springframework.context.ApplicationContext;import org.springframework.context.ApplicationContextAware;public class MailSender implements ApplicationContextAware &#123; private ApplicationContext ctx; @Override public void setApplicationContext(ApplicationContext ctx) throws BeansException &#123; this.ctx = ctx; &#125; public void sendMail(String to) &#123; System.out.println("MailSender：模拟发送邮件..."); MailSendEvent mse = new MailSendEvent(this.ctx, to); ctx.publishEvent(mse); &#125;&#125;// Spring配置文件&lt;?xml version="1.0" encoding="UTF-8" ?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-3.1.xsd"&gt; &lt;bean class="com.hhxs.bbt.event.MailSendListener"/&gt; &lt;bean id="mailSender" class="com.hhxs.bbt.event.MailSender"/&gt;&lt;/beans&gt;// 测试类ApplicatonEventTestpackage com.hhxs.bbt.event;import org.springframework.context.ApplicationContext;import org.springframework.context.support.ClassPathXmlApplicationContext;public class ApplicatonEventTest &#123; public static void main(String[] args) &#123; String resourceFile = "com/hhxs/bbt/event/beans.xml"; ApplicationContext ctx = new ClassPathXmlApplicationContext(resourceFile); MailSender mailSender = ctx.getBean(MailSender.class); mailSender.sendMail("event@mail.com"); System.out.println("done."); &#125;&#125; 运行结果如下：123MailSender：模拟发送邮件...MailSendListener：向event@mail.com发送完一封邮件done.]]></content>
      <categories>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring3.X学习笔记3-基于注解和基于Java类的配置]]></title>
    <url>%2F2017%2F11%2F07%2FSpring3.X%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B03-%E5%9F%BA%E4%BA%8E%E6%B3%A8%E8%A7%A3%E7%9A%84%E9%85%8D%E7%BD%AE%E5%92%8C%E5%9F%BA%E4%BA%8EJava%E7%B1%BB%E7%9A%84%E9%85%8D%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[上一篇文章里我们主要介绍了基于XML Schemal的配置方式。本篇文章里将介绍另外两种提供Bean定义的方式，基于注解和基于Java类的配置。 1、基于注解的配置不管是XML还是注解，他们都是表达Bean定义的载体，其实质都是为Spring容器提供Bean定义的信息，表现形式上是将XML定义的东西通过类注解进行描述。Spring从2.0开始引入基于注解的配置方式，在3.0时得到进一步的完善。下面是使用注解定义一个DAO的Bean:12345678package com.hhxs.bbt.dao;import org.springframework.stereotype.Component;// 1.通过Repository定义一个DAO的Bean@Component("userDao")public class UserDao &#123; ...&#125; 在上面1处，使用@Component注解在UserDao类声明处对类进行标注，它可以被Spring容器识别，Spring容器自动将POJO转换为容器管理的Bean。它和以下的XML配置是等效的：1&lt;Bean id="userDao" class="com.hhxs.bbt.dao.UserDao"&gt; 除了@Component以外，Spring提供了三个功能基本和@Component等效的注解，它们分别用于对DAO、Service及Web层的Controller进行注解，所以也称这些注解为Bean的衍型注解： @Repository：用于对DAO实现类进行标注； @Service：用于对Service实现类进行标注； @Controller：用于对Controller实现类进行标注。 在@Component之外提供这三个注解，是为了让注解类本身的用途更加清晰，此外Spring还赋予了它们一些特殊功能。 1.1 使用注解配置信息启动Spring容器Spring在2.5 后提供了一个context的命名空间，它提供了通过扫描类包以应用注解定义Bean的方式： 12345678910111213&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:context="http://www.springframework.org/schema/context" xsi:schemaLocation="http://www.springframework.org/schema/beans" http://www.springframework.org/schema/beans/spring-beans-3.1.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-3.1.xsd&gt; &lt;description&gt;Spring公共配置 &lt;/description&gt; &lt;!-- 1.扫描类包以应用注解定义的Bean --&gt; &lt;context:component-scan base-package="com.hhxs.bbt" /&gt;&lt;/beans&gt; 在上面1处通过context命名空间的compnent-scan的base-package属性指定一个需要扫描的基类包，Spring容器将会扫描这个基类包里的所有类，并从类的注解信息中获取Bean的定义信息。 如果仅希望扫描特定的类而非基包下的所有类，那么可以使用resource-pattern属性过滤特定的类，如下所示： 1&lt;context:component-scan base-package="com.hhxs.bbt" resource-pattern="dao/*.class"/&gt; 默认情况下resource-pattern属性的值为**/*.class，即基包里的所有类。这里我们设置为dao/*.class，则Spring仅会扫描基包里dao子包中的类。通过resource-pattern属性仅可按资源名称对基包中的类进行过滤，如果需要更详细的过滤，则需要用到&lt;contex:component-scan&gt;的过滤子元素： 1234&lt;context:component-scan base-package="com.hhxs.bbt"&gt; &lt;context:include-filter type="regex" expression="com.\hhxs.\bbt.*"/&gt; &lt;context:exclude-filter type="aspectj" expression="com.hhxs.bbt..*Controller+"/&gt;&lt;/context&gt; &lt;context:include-filter&gt;表示要包含的目标类 &lt;context:exclude-filter&gt;表示要排除在外的目标类 一个&lt;context:component-scan&gt;下可以包含若干个&lt;context:include-filter&gt;和&lt;context:exclude-filter&gt;元素。这两个过滤元素均支持多种类型的过滤表达式，如下表所示： 类别 示例 说明 annotation com.hhxs.bbt.XxxAnnotation 所有标注了XxxAnnotation的类。该类型采用目标类是否标注了某个注解进行过滤。 assignable com.hhxs.bbt.XxxService 所有继承或扩展XxxService的类。该类型采用目标类是否继承或扩展某个特定类进行过滤。 aspectj com.hhxs.bbt..*Service+ 所有类名以Service结束的类及继承或扩展它们的类。该类型采用AspectJ表达式进行过滤。 regex com.hhxs.bbt..* 所有com.hhxs.bbt类包下的类。该类型采用正则表达式根据目标类的类名进行过滤。 custom com.hhxs.bbt.XxxTypeFilter 采用XxxTypeFilter通过代码的方式根据过滤规则。该类必须实现org.springframework.core.type.TypeFilter接口 1.2 自动装配Beanspring使用@Autowired注解实现Bean的依赖注入。@Autowired默认按类型匹配的方式，在容器查找匹配Bean,当且仅有一个匹配的Bean时，Spring将其注入到@Autowired标注的变量中。 123456789101112131415package com.hhxs.bbt.service;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.stereotype.Service;@Servicepublic class LogonService &#123; @Autowired private LogDao logDao; @Autowired private UserDao userDao; ...&#125; 如果容器中没有一个和标注变量类型匹配的bean，Spring容器启动时将报NoSuchBeanDefinitionException异常。如果希望不抛出异常可以使用@Autowired(required=false)进行标注。默认情况下，@Autowired的required属性值为true。 如果容器中有一个以上匹配的Bean时，可以通过@Qualifier注解限定Bean的名称。 1234567891011121314151617package com.hhxs.bbt.service;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.beans.factory.annotation.Qualifier;import org.springframework.stereotype.Service;@Servicepublic class LogonService &#123; @Autowired private LogDao logDao; @Autowired @Qualifier("userDao") private UserDao userDao; ...&#125; 对集合类进行标注如果对类中集合类的变量和方法入参进行@Autowired标注，Spring会将容器中类型匹配的所有Bean都自动注入进来。这是一个很好的特性，所以在这里介绍下。 1234567891011121314151617package com.hhxs.bbt.service;import java.util.List;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.beans.factory.annotation.Qualifier;import org.springframework.stereotype.Service;@Servicepublic class MyComponent &#123; // Spring会将容器中所有类型为Plugin的Bean注入到这个变量中 @Autowired(required=false) private List&lt;Plugin&gt; plugins; public List&lt;Plugin&gt; getPlugins() &#123; return plugins; &#125;&#125; Spring如果发现变量是一个集合类，则它会将容器中匹配集合元素类型的所有Bean都注入进来。这里，Plugin为一个接口，它拥有两个实现类，分别是OnePlugin和TwoPlugin，这两个实现类都通过@Component标注为Bean，则Spring会将这两个Bean都注入到plugins中。 2、基于Java类的配置2.1 使用Java类提供Bean定义信息JavaConfig是Spring的一个子项目，它旨在通过Java类的方式提供Bean的定义信息。Spring3.0基于Java类配置的核心即取材于JavaConfig。 普通的POJO只要标注@Configuration注解，就可以为Spring容器提供Bean定义的信息了，每个标注了@Bean的类方法都相当于提供一个Bean的定义信息。 12345678910111213141516171819202122232425import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;// 1.将一个POJO标注定义为Bean的配置类@Configurationpublic class AppConf &#123; // 2.以下两个方法定义了两个Bean，并提供了Bean的实例化逻辑 @Bean public UserDao userDao() &#123; return new UserDao(); &#125; @Bean public LogDao logDao() &#123; return new LogDao() &#125; @Bean public LogonService logonService() &#123; LogonServcie logonService = new LogonService(); // 将上面2处定义的Bean注入到logonService的Bean logonService.setLogDao(logDao()); logonService.setUserDao(userDao()); return logonService; &#125;&#125; 1处在AppConf类的定义处标注了@Configuration注解，说明这个类可用于为Spring提供Bean信息。类的方法出可以标注@Bean注解，Bean的类型由方法返回值类型决定，名称默认和方法名相同，也可通过@Bean(name=”userDao”)显示指定Bean的名称。 上面的配置和以下XML配置等效： 1234&lt;bean id="userDao" class="com.hhxs.bbt.dao.UserDao" /&gt;&lt;bean id="logDao" class="com.hhxs.bbt.dao.LogDao" /&gt;&lt;bean id="userDao" class="com.hhxs.bbt.conf.LogonService" p:logDao-ref="userDao" p:userDao-ref="logDao" /&gt; 2.2 使用基于Java类的配置信息启动Spring容器2.2.1 直接通过@Configuration类启动Spring容器Spring提供了一个AnnotationConfigApplicationContext类，它能够直接通过标注@Configuration的Java类启动Spring容器。以下两种方式是等效的： 第一种： 123456789101112package com.hhxs.bbt.conf;import org.springframework.context.ApplicationContext;import org.springframework.context.annotation.AnnotationConfigApplicationContext;public class JavaConfigTest &#123; public static void main(String[] args) &#123; ApplicationContext ctx = new AnnotationConfigApplicationContext(AppConf.class); LogonService logonService = ctx.getBean(logonService.class); logonService.printHello(); &#125;&#125; 第二种：1234567891011121314151617package com.hhxs.bbt.conf;import org.springframework.context.ApplicationContext;import org.springframework.context.annotation.AnnotationConfigApplicationContext;public class JavaConfigTest &#123; public static void main(String[] args) &#123; AnnotationConfigApplicationContext ctx = new AnnotationConfigApplicationContext(); // 注册多个@Configuration配置类 ctx.register(DaoConfig.Class); ctx.register(ServiceConfig.class); // 刷新容器以应用这些注册的配置类 ctx.refresh(); LogonService logonService = ctx.getBean(logonService.class); logonService.printHello(); &#125;&#125; 可以通过代码一个一个注册配置类，也可以通过@Import将多个配置类组装到一个配置类中，这样仅需要注册这个组装好的配置类就可以启动容器了。1234567891011121314package com.hhxs.bbt.conf;import org.springframework.beans.factory.annotation.Configurable;import org.springframework.context.annotation.Import;@Configurable@Import(DaoConfig.class)public class ServiceConfig &#123; @Bean public LogonService logonService() &#123; LogonService logonService = new LogonService(); return logonService; &#125;&#125; 我们既可以在XML配置文件中引用@Configuration的配置，也可以通过Configuration配置类中引用XML配置信息。只要不同形式的Bean定义信息能够加载到Spring容器中，Spring就能足够“智能”的完成Bean之间的装配。 3、不同配置方式比较配置方式比较： – 基于XML配置 基于注解配置 基于Java类配置 Bean定义 &lt;bean class=&quot;com.hhxs.bbt.UserDao&quot;&gt; Bean实现类出通过标注 @Component、@Repository、@Service、@Controller 在标注了@Configuration的Java类中，通过在类方法上标注@Bean定义一个Bean。方法必须提供Bean的实例化逻辑。 Bean名称 通过的id或name属性定义 通过注解的value属性定义，如@Component(“userDao”)。默认名称为小写字母打头的类名（不带包名）：userDao 通过@Bean的name属性定义，如@Bean(“userDao”)，默认名称为方法名。 Bean注入 通过子元素或通过p命名空间的动态属性 通过在成员变量或方法入参出标注@Autowired，按类型匹配自动注入 可以通过在方法处通过@Autowired使方法入参绑定Bean，然后在方法中通过代码进行注入，还可以通过调用配置类的@Bean方法进行注入 Bean生命过程方法 通过的init-method和destory-method属性指定Bean实现类的方法名。最多只能指定一个初始化方法和一个销毁方法 通过在目标方法上标注@PostConstruct和@PreDestroy注解指定初始化或销毁方法，可以定义任意多个方法 通过@Bean的initmethod或destoryMethod指定一个初始化或销毁方法。 Bean作用范围 通过的scope属性指定 通过在类定义出标注@Scope指定 通过在Bean方法定义处标注@Scope指定 Bean延迟初始化 通过的lazy-init属性指定，默认为default，继承与的default-lazy-init设置，该值默认为false 通过在类定义处标注@Lazy指定，如@Lazy(true) 通过在Bean方法定义处标注@Lazy指定 使用场景建议： – 基于XML配置 基于注解配置 基于Java类配置 适合场景 1）Bean实现类来源于第三方类库 2）命名空间的配置 Bean实现类是当前项目开发的，可以直接在Java类中使用基于注解的配置 基于Java类配置的优势在于可以通过代码方式控制Bean初始化的整体逻辑。]]></content>
      <categories>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>Bean</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring3.X学习笔记2-Bean的基本配置]]></title>
    <url>%2F2017%2F11%2F07%2FSpring3.X%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B02-Bean%E7%9A%84%E5%9F%BA%E6%9C%AC%E9%85%8D%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[知易行难，由于之前很少写技术博客，对于写一篇“还算正式”的技术文章需要花费多少时间并不清楚。第一篇笔记整理了将近一周，这远远超出了我的预期。写完的时候，不免想起那些经常写博客的人一定花费了很多的心思在上面，因而心生佩服。很多事情都是这样，只有做过才会知道其中的不容易。 1、Spring配置概述1.1 Spring容器高层视图Spring容器根据各种形式的Bean配置信息在容器内部建立Bean定义注册表，然后根据注册表加载、实例化Bean，并建立Bean和Bean的依赖关系。Bean的配置信息是Bean的元数据信息，Bean的元数据信息在Spring容器中的内部对应物是由一个一个BeanDefinition形成的Bean注册表，Spring实现了Bean元数据信息内部表示和外部表示的解耦。如下图： 1.2 基于XML Schema的配置基于XML的配置，Spring2.0以后开始使用Schema格式，相比Spring1.0的DTD格式，Schema让不同类型的配置拥有了自己的命名空间，使配置文件更具扩展性。下面看一个简单的示例： Schema在文档根节点中通过xmlns对文档中的命名空间进行声明。在上面的代码中定义了3个命名空间： 默认命名空间：它没有空间名，用于Spring Bean的定义； xsi命名空间：这个命名空间用于为每个文档中命名空间指定相应的Schema样式文件，是标准组织定义的标准命名空间； aop命名空间：这个命名空间是Spring配置Aop的命名空间，是用户自定义的命名空间； 命名空间的定义分为两个步骤：第一步指定命名空间的名称，第二部指定命名空间Schema文档样式文件的位置，用空格或回车换行进行分割。在第二步中，指定命名空间的Schema文件地址有两个用途：XML解析器可以获取Schema文件并对文档进行格式合法性验证；在开发环境下，IDE可以引用Schema文件对文档编辑提供诱导功能。 2、Bean的基本配置2.1 Bean配置的基础知识一般情况下，Spring IoC容器中的一个Bean即对应配置文件中的一个&lt;bean&gt;，其中id为这个Bean的名称，通过容器的getBean(id)即可获取对应的Bean，在容器中起到定位查找的作用。class属性指定了Bean对应的实现类。1&lt;bean id="foo" class="com.hhxs.domain.Foo"&gt; id在IoC的容器中必须是唯一的，此外id的命名也需要满足XML对id的命名规范（id是XML规定的特殊属性）：必须以字母开始，后面可以是字母、数字、连字符、下划线、句号、冒号的完整结束的符号，逗号和空格这些非完整结束符是非法的。name属性没有字符上的限制，几乎可以使用任何字符。另外id和name都可以指定多个名字，名字之间用逗号、分号或者空格进行分隔：1&lt;bean name="foo,#foo,$foo" class="com.hhxs.domain.Foo"&gt; 可以使用getBean(“foo”)、getBean(“#foo”)、getBean(“$foo”)获取IoC容器中的Foo Bean。Spring配置文件中不允许出现两个相同id的&lt;bean&gt;，但可以出现两个相同name的&lt;bean&gt;，多个name相同的&lt;bean&gt;，通过getBean(beanName)获取Bean时，将返回最后声明的那个Bean。如果id和name两属性都未指定，如&lt;bean class=&quot;com.baobaotao.simple.Car&quot;&gt;，Spring自动将全限定类名作为Bean的名称。 2.2 注入方式Spring支持两种依赖注入方式，分别是属性注入和构造函数注入。除此之外，Spring还支持工厂方法注入方式。 2.2.1 属性注入属性注入是配置Bean之间的依赖关系最常用的一种方式，属性注入要求Bean提供一个默认的构造函数，并为需要注入的属性提供对应的Setter方法。Spring先调用Bean的默认构造函数实例化Bean对象，然后通过反射的方式调用Setter方法注入属性值。JavaBean的属性命名规范：xxx的属性对应setXxx()方法。一般情况下，Java的属性变量名都以小写字母起头，特殊情况下，也允许大写字母起头的属性变量名，但是必须满足“变量的前两个字母要么全部大写，要么全部小写”。下面看一个例子：12345678910111213141516171819202122232425public class Car &#123; private String brand; private String color; private int maxSpeed; public void setBrand(String brand) &#123; System.out.println("调用setBrand()设置属性。"); this.brand = brand; &#125; public void setColor(String color) &#123; this.color = color; &#125; public void setMaxSpeed(int maxSpeed) &#123; this.maxSpeed = maxSpeed; &#125; ......&#125;// Spring配置文件中的属性注入配置&lt;bean id="car" class="com.hhxs.bbt.web.Car" &gt; &lt;property name="brand"&gt;&lt;value&gt;红旗CA72&lt;/value&gt;&lt;/property&gt; &lt;property name="color"&gt;&lt;value&gt;红色&lt;/value&gt;&lt;/property&gt; &lt;property name="maxSpeed"&gt;&lt;value&gt;200&lt;/value&gt;&lt;/property&gt;&lt;/bean&gt; Bean的每一个属性对应一个标签，如maxSpeed对应setMaxSpeed()。 提示:默认构造函数是不带参的构造函数。Java语言规定如果类中没有定义任何构造函数，则JVM自动为其生成一个默认的构造函数。反之，如果类中显示定义了构造函数，则JVM不会为其生成默认的构造函数。 2.2.2 构造函数注入构造函数注入方式是除属性注入之外的另一种常用的注入方式，它保证一些必要的属性在Bean实例化时就得到设置，它保证了Bean实例在实例化后就可以使用。其中构造参数注入又分为，按类型匹配入参、按索引匹配入参、联合使用类型和索引匹配入参等。这是因为Java反射机制并不会记住构造函数的入参名，我们无法通过指定构造函数的入参名进行构造函数注入的配置，而只能通过入参类型和索引信息间接确定构造函数配置项和入参的对应关系。下面直接看一个联合使用类型和索引匹配入参的代码片段：123456789101112131415161718192021222324252627...public Car(String brand, String corp, double price) &#123; this.brand = brand; this.corp = corp; this.price = price;&#125;public Car(String brand, String corp, int maxSpeed) &#123; this.brand = brand; this.corp = corp; this.maxSpeed = maxSpeed;&#125;...// Spring配置文件中的配置&lt;!-- 对应Car(String brand, String corp, int maxSpeed)构造函数 --&gt;&lt;bean id="car" class="com.hhxs.bbt.web.Car" &gt; &lt;constructor-arg index="0" type="java.lang.String"&gt; &lt;value&gt;红旗CA72&lt;/value&gt; &lt;/constructor-arg&gt; &lt;constructor-arg index="1" type="java.lang.String"&gt; &lt;value&gt;中国一汽&lt;/value&gt; &lt;/constructor-arg&gt; &lt;constructor-arg index="2" type="int"&gt; &lt;value&gt;200&lt;/value&gt; &lt;/constructor-arg&gt;&lt;/bean&gt; 如果构造函数没有歧义的话，上面配置文件中的type属性和index属性均可去除。另外如果，Bean构造函数入参的类型是可辨别的（非基础数据类型且入参类型各异），构造函数注入的配置也是可以不提供类型和索引的信息，但是为了避免潜在配置歧义问题，如果Bean存在多个构造函数，使用显示指定index和type属性不失为一种良好的配置习惯。 2.2.3 工厂注入方法Spring IoC容器以框架的方式提供工厂方法的功能，并以透明的方式开放给开发者，所以很少需要手工编写基于工厂方法的类。正因为此，工作方法对于实际编码的重要性大大降低，它将慢慢地淡出开发人员的视野，这里不在说明。 2.2.4 注入方式的选择支持构造函数注入方式的理由： 构造函数可以保证一些重要的属性在Bean实例化时就设置好，避免因为一些重复属性没有提供，导致一个无用Bean实例的情况； 不需要为每个属性提供Setter方法，减少了类的方法个数； 可以更好地封装类变量，不需要为每个属性指定Setter方法，避免外部错误的调用。 支持属性注入方式的理由： 如果一个类的属性众多，构造函数的签名将变成一个庞然大物，可读性很差； 灵活性不够，在有些属性是可选的情况下，如果通过构造函数注入，也需要为可选的参数提供一个null值； 如果有多个构造函数，需要考虑配置文件和具体构造函数匹配歧义的问题，配置上相对复杂； 构造函数不利于类的继承和扩展，因为子类需要引用到父类复杂的构造函数； 构造函数注入有时会造成循环依赖的问题。 两种方式各有优缺点，生产环境中要根据实际情况使用。除了工厂方法的注入方式已不再使用，属性注入和构造函数注入方式都是比较常用的。 2.3 简化配置方式在之前的例子里我们采用完整配置格式的配置方式，也许你已经发现这种方式显得比较拖沓。如果系统中拥有大量的类需要配置，我们一定会感到崩溃。还好Spring为我们提供了简化的配置方式。如果没有用到完整配置格式的特殊功能，我们一般都只使用简化的配置方式。 字面值属性： 简化前 简化后 字面值属性 &lt;property name=&quot;maxSpeed&quot;&gt; &lt;value&gt;你好&lt;/value&gt; &lt;/property&gt; &lt;property name=&quot;maxSpeed&quot; value=&quot;200&quot;/&gt; 构造函数参数 &lt;constructor-arg type=&quot;java.lang.String&quot;&gt; &lt;value&gt;红旗CA72&lt;/value&gt; &lt;/constructor-arg&gt; &lt;constructor-arg type=&quot;java.lang.String&quot; value=&quot;红旗CA72&quot;/&gt; 集合元素 &lt;map&gt; &lt;entry&gt; &lt;key&gt;&lt;value&gt;AM&lt;/value&gt;&lt;/key&gt; &lt;value&gt;会见客户&lt;value&gt; &lt;/entry&gt; &lt;/map&gt; &lt;map&gt; &lt;entry key=&quot;AM&quot; value=&quot;会见客户&quot;/&gt; &lt;/map&gt; 引用对象属性： 简化前 简化后 字面值属性 &lt;property name=&quot;car&quot;&gt; &lt;ref bean=&quot;car&quot;&gt;&lt;/ref&gt; &lt;/property&gt; &lt;property name=&quot;car&quot; ref=&quot;car&quot;/&gt; 构造函数参数 &lt;constructor-arg&gt; &lt;ref bean=&quot;car&quot;/&gt; &lt;/constructor-arg&gt; &lt;constructor-arg ref=&quot;car&quot;/&gt; 集合元素 &lt;map&gt; &lt;entry&gt; &lt;key&gt;&lt;ref bean=&quot;keyBean&quot;/&gt;&lt;/key&gt; &lt;ref bean=&quot;valueBean&quot;/&gt; &lt;/entry&gt; &lt;/map&gt; &lt;map&gt; &lt;entry key-ref=&quot;keyBean&quot; value-ref=&quot;valueBean&quot;/&gt; &lt;/map&gt; 使用P命名空间：为了简化XML文件的配置，越来越多的XML文件采用属性而非子元素配置信息。Spring从2.5版本开始引入了一个新的p命名空间，可以通过&lt;bean&gt;元素属性的方式配置Bean的属性。 未采用P命名空间前：123456789101112131415&lt;?xml version="1.0" encoding="UTF-8" ?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-3.0.xsd"&gt; &lt;bean id="car" class="com.hhxs.bbt.web.Car" &gt; &lt;property name="brand" value="红旗CA72" /&gt; &lt;property name="color" value="红色" /&gt; &lt;property name="maxSpeed" value="200" /&gt; &lt;/bean&gt; &lt;bean id="boss" class="com.hhxs.bbt.web.Boss"&gt; &lt;property name="car" ref="car"/&gt; &lt;/bean&gt;&lt;/beans&gt; 采用P命名空间后：1234567891011121314&lt;?xml version="1.0" encoding="UTF-8" ?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:p="http://www.springframework.org/schema/p" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-3.0.xsd"&gt; &lt;bean id="car" class="com.hhxs.bbt.web.Car" p:brand="红旗CA72" p:color="红色" p:maxSpeed="200"/&gt; &lt;bean id="boss" class="com.hhxs.bbt.web.Boss" p:car-ref="car"/&gt;&lt;/beans&gt; 未采用p命名空间前&lt;bean&gt;使用&lt;property&gt;子元素配置Bean的属性，采用p命名空间后，采用&lt;bean&gt;的元素属性配置Bean的属性。 对于字面值属性，其格式为： p:&lt;属性名&gt;=&quot;xxx&quot; 对于引用对象的属性，其格式为：p:&lt;属性名&gt;-ref=“xxx” 由于p命名空间中的属性名是可变的，所以p命名空间没有对应的Scheam定义文件，也就不需要在xsi:schemaLocation中为p命名空间指定Schema定义文件。 3. 自动装配Spring IoC容器了解容器中所有Bean的配置信息，此外通过Java反射机制还可以获取已知实现你类的结构信息（如构造函数方法的结构、属性等信息）。掌握容器中所有Bean的这些信息后，Spring IoC容器就可以按照某种规则对容器中的Bean进行自动装配，而无须我们通过显示的方式进行配置。 &lt;bean&gt;元素提供了一个指定自动个装配类型的属性：autowire=”&lt;自动装配类型&gt;”。Spring提供了4种自动装配类型： 自动装配类型 说明 byName 根据名称进行自动匹配。假设Boss有一个名为car的属性，如果容器中刚好有一个名为car的Bean，Spring就会自动将其装配给Boss的car属性。 byType 根据类型进行自动匹配。假设Boss有一个car类型的属性，如果容器中刚好有一个car类型的Bean，Spring就会自动将其装配给Boss的这个属性。 constructor 与ByType类似，只不过它是针对构造函数注入而言的，如果Boss有一个构造函数，构造函数包含一个Car类型的入参，如果容器中有一个Car类型的Bean，则Spring将自动把这个Bean作为Boss构造函数的入参，如果容器中没有找到和构造函数入参匹配类型的Bean，Spring将抛出异常。 autodetect 根据Bean的自省机制决定采用byType还是constructor进行自动装配：如果Bean提供了默认的构造函数，则采用byType; 否则采用constructor &lt;beans&gt;元素标签中的default-autowire属性可以配置全局自动匹配，default-autowire属性的默认值为no，表示不启用自动装配，其他几个配置值为：byName、byType、constructor、autodetect，意义同上面的表格。注意：&lt;beans&gt;中定义的自动装配策略可以被&lt;bean&gt;的自动装配策略覆盖。 注意：自动装配机制在减轻配置工作量的同时也会造成配置文件中Bean之间关系不清晰的问题，生产使用时要根据实际项目情况。 4. 整合多个配置文件对于一个大型应用来说，可能有多个XML配置文件，在启动时，可以通过一个String数组指定这些配置文件。Spring还允许我们通过&lt;import&gt;将多个配置文件引入到一个文件中，进行配置文件的集成。如下，beans2.xml引入了beans1.xml配置文件：123&lt;import resource="classpath:beans1.xml"/&gt;&lt;bean id="boss1" class="com.hhsx.bbt.web.Boss" p:car-ref="car1"/&gt;&lt;bean id="boss2" class="com.hhxs.bbt.web.Boss" p:car-ref="car2"/&gt; 假设我们已经在beans1.xml中配置了car1和car2的Bean,通过&lt;import&gt;引入beans1.xml，beans2.xml就拥有了完整的配置信息。Spring容器仅需要通过beans2.xml就可以加载到所有的配置信息了。 5. Bean作用域在配置文件中定义Bean时，除了可以配置Bean的属性值以及相互之间的依赖关系，还可以定义Bean的作用域。 Bean的作用域类型： 类别 说明 singleton 在Spring IoC容器中仅存在一个Bean实例，Bean以单实例的方式存在 。在Spring中，Bean的默认作用域为singleton。如果不希望在容器启动时提前实例化Bean，可以通过lazy-init属性进行控制。 prototype 每次从容器中调用Bean时，都返回一个新的实例，即每次调用getBean()时，相当于执行new XxxBean()的操作 request 每次HTTP请求都会创建一个新的Bean。该作用域仅适用于WeApplicationContext环境。 session 同一个HTTP Session共享一个Bean，不同HTTP Session使用不同的Bean。该作用域仅适用于WeApplicationContext环境。 globalSession 同一个全局Session共享一个Bean， 一般用于Porlet应用环境。该作用域仅适用于WeApplicationContext环境。 使用方式是： scope=&quot;&lt;作用域类型&gt;&quot;]]></content>
      <categories>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>Bean</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring3.X学习笔记1-IoC容器概述]]></title>
    <url>%2F2017%2F10%2F28%2FSpring%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B01-IoC%E5%AE%B9%E5%99%A8%E6%A6%82%E8%BF%B0%2F</url>
    <content type="text"><![CDATA[2017即将接近尾声，每当年末的时候总要检查下今年还有什么事情没做，结果却发现今年好像也没做多少事情😶。于是就想着把之前一直想梳理的Spring知识，趁着年末好好整理下。本系列笔记基于”Spring3.x企业应用开发实战“一书，说来惭愧，书买了好多年了也没认真的看一遍，于是就有了这个想法，算是2017年的最后给自己的一份交代。 在开始之前，先简要介绍下Spring吧！ Spring是分层的Java SE/EE应用一站式的轻量级开源框架，由Rod Johnson创建，以IoC和AOP为内核，提供了展现层Spring MVC和持久层Spring JDBC以及业务层事务管理等众多企业级应用技术，并以海纳百川的胸怀整合了开源世界里众多的企业级应用技术，逐渐成为使用最多的Java EE企业应用开发框架。 1、IoC概述1.1 IoC的概念IoC（控制反转：Inverse of Control）是一个重要的面向对象编程理论，Spring核心模块实现了IoC的功能。Spring中的其他模块，像AOP、声明式事务等功能都是建立在IoC的基础之上，它将类和类之间的依赖从代码中脱离出来，用配置的方式进行依赖关系描述，由IoC容器负责依赖类之间的创建、拼接、管理、获取等工作。一般来说IoC的概念有两种表示方式，一个叫控制反转，一个叫依赖注入。由于控制反转并不好理解，业界也曾进行广泛的讨论，最终软件界的泰斗级人物Martin Folwer提出了DI（依赖注入：Dependency Injection）的概念用以代替IoC。 控制反转：对于软件来说，即某一接口具体实现类的选择控制权从调用类中移除，转交给第三方决定。 依赖注入：调用类对某一接口实现类的依赖关系由第三方（容器或协作类）注入，以移除调用类对某一接口实现类的依赖。 上面两个概念第一次接触的时候，你会发现都不太好理解，那是因为还不清楚IoC的实现机制，随着对IoC了解的深入，你会发现依赖注入的概念直接明了。 1.2 IoC的类型从注入方法上看，主要可以划分为三种类型：构造函数注入、属性注入和接口注入。Spring支持构造函数注入和属性注入。 构造函数注入: 在构造函数注入中，我们通过调用类的构造函数，将接口实现类通过构造函数变量传入。 属性注入: 属性注入是指通过Setter方法完成调用类所需依赖的注入。 接口注入: 将调用类所有依赖注入的方法抽取到一个接口中，调用类通过实现该接口提供相应的注入方法。 由于通过接口注入需要额外声明一个接口，增加了类的数目，而且它的效果和属性注入并无本质区别，所以不提倡采用这种方式。 2、IoC的底层实现原理Spring的核心模块实现了IoC的功能，它通过配置文件或注解描述类和类之间的依赖关系，自动完成类的初始化和依赖注入的工作。让开发者们从底层实现类的实例化、依赖关系装配等工作中脱离出来，专注于更有意义的业务逻辑开发工作。这种“神奇”的力量归功于Java语言本身的类反射功能。 2.1 Java反射知识Java语言允许通过程序化的方式间接对Class的对象实例操作，Class文件由类装载器装载后，在JVM中将形成一份描述CLass结构的元信息对象，通过该元信息对象可以获知Class的结构信息：如构造函数、属性和方法等。Java允许用户借由这个Class相关的元信息对象间接调用Class对象的功能，这就为使用程序化方式操作Class对象开辟了途径。下面先看一个例子： 1234567891011121314151617181920212223242526272829303132333435363738394041424344public class Car &#123; private String brand; private String color; private int maxSpeed; public Car() &#123;&#125; public Car(String brand, String color, int maxSpeed) &#123; this.brand = brand; this.color = color; this.maxSpeed = maxSpeed; &#125; public void introduce() &#123; System.out.println("brand:" + brand + ";color:" + color + ";maxSpeed:" + maxSpeed); &#125; // 省略参数的getter/Setter方法&#125;public class ReflectTest &#123; public static Car initByDefaultConst() throws Throwable &#123; // 通过类装载器获取Car类对象 ClassLoader loader = Thread.currentThread().getContextClassLoader(); Class&lt;?&gt; clazz = loader.loadClass("com.hhxs.bbt.web.Car"); // 获取类的默认构造器对象并通过它实例化Car Constructor&lt;?&gt; cons = clazz.getDeclaredConstructor((Class[]) null); Car car = (Car) cons.newInstance(); // 通过反射方法设置属性 Method setBrand = clazz.getMethod("setBrand", String.class); setBrand.invoke(car, "红旗CA72"); Method setColor = clazz.getMethod("setColor", String.class); setColor.invoke(car, "黑色"); Method setMaxSpeed = clazz.getMethod("setMaxSpeed", int.class); setMaxSpeed.invoke(car, 200); return car; &#125; public static void main(String[] args) throws Throwable &#123; Car car1 = initByDefaultConst(); car1.introduce(); &#125;&#125; 通过查看运行结果，可以看到这和直接通过构造函数和方法调用类功能的效果是一致的，只不过前者是间接调用，后者是直接调用罢了。这说明我们完全可以通过编程方式调用Class的各项功能。如果我们将这些信息以一个配置文件的方式提供，就可以使用Java语言的反射功能编写一段通用代码对类似于Car的类进行实例化及功能调用操作了。有没有感觉这和上面提到的Spring框架的实现机制很相似，Spring正是基于Java语言自带的反射机制实现了IoC的功能。 下面简要介绍下上述例子用到得三个主要反射类，这些反射对象类在java.reflect包中定义: Constructor: 类的构造函数反射类，通过Class#getConstructors()方法可以获得类的所有构造函数反射对象数组。Constructor的一个主要方法是newInstance(Object[]… initargs)，通过该方法可以创建一个对象类的实例，相当new关键字。 Method: 类方法的反射类，通过Class#getDeclaredMethods()方法可以获取类的所有方法发射类对象数组Method[]。Method最主要的方法是invoke(Object obj, Objcet… args)，obj表示操作的目标对象，args为方法入参。 Field: 类的成员变量反射类，通过Class#getDeclaredFields()方法可以获取类的成员变量反射对象数组。Filed类最主要的方法是set(Object obj, Object value)，obj表示操作的目标对象，通过value为目标类对象的成员变量设置值。 此外，Java还为包提供了Package反射类，在JDK5.0中还未注解提供了AnnotatedElement反射类。总之，Java的反射体系保证了可以通过程序化的方式访问目标类中的所有元素，对于private或protected的成员变量和方法，只要JVM的安全机制允许，也可以通过反射进行调用setAccessible(boolean access)。 3、三个核心接口Spring通过一个配置文件描述Bean及Bean之间的依赖关系，利用Java语言的反射功能实例化Bean并建立Bean之间的依赖关系。Spring的IoC容器在完成这些底层工作的基础上，还提供了Bean实例缓存、声明周期管理、Bean实例代理、事件发布、资源装载等高级服务。 3.1 BeanFactoryBean工厂(com.springframework.beans.factory.BeanFactory)是Spring框架最核心的接口，它提供了高级IoC的配置机制。BeanFactory使管理不同不同类型的Java对象成为可能，一般称BeanFactory为IoC容器。BeanFactory是类的通用工厂，它可以创建并管理各种类的对象，Spring称这些被创建和管理的Java对象为Bean。Bean最主要的方法就是getBean(String beanName)，该方法从容器中返回特定名称的Bean。下面看一个小例子:1234567891011121314151617181920212223242526// spring文件&lt;?xml version="1.0" encoding="UTF-8" ?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:p="http://www.springframework.org/schema/p" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-3.0.xsd"&gt; &lt;bean id="car" class="com.hhxs.bbt.web.Car" p:brand="红旗CA72" p:color="黑色" p:maxSpeed="200" /&gt;&lt;/beans&gt;// JAVA代码public class BeanFactoryTest &#123; public static void main(String[] args) throws Throwable&#123; ResourcePatternResolver resolver = new PathMatchingResourcePatternResolver(); Resource res = resolver.getResource("classpath:spring/beans.xml"); System.out.println(res.getURL()); BeanFactory bf = new XmlBeanFactory(res); System.out.println("init BeanFactory."); Car car = bf.getBean("car",Car.class); System.out.println("car bean is ready for use!"); car.introduce(); &#125;&#125; 注意： 通过BeanFactory启动IoC容器时，并不会初始化配置文件中定义的Bean，初始化动作发生在第一次调用时。对于单实例的Bean来说，BeanFactory会缓存Bean实例，所以第二次使用getBean()获取Bean时将直接从IoC容器的缓存中获取Bean实例。Spring在DefaultSingletonBeanRegistry类中提供了一个用于缓存单实例Bean的缓存器，它是一个用HashMap实现的缓存器，单实例的Bean以beanName为键保存在这个HashMap中。 3.2 ApplicationContext应用上下文(com.springframework.context.ApplicationContext)建立在BeanFactory基础之上，提供了更多面向应用的功能，它提供了国际化支持和框架事件体系，更易于创建实际应用。一般称ApplicationContext为应用上下文或者Spring容器。 ApplicationContext的主要实现类是ClassPathXmlApplicationContext和FileSystemXmlApplicationContext，前者默认从类路径中加载配置文件，后者默认从文件系统中装载配置文件。 123ApplicationContext ctx = new ClassPathXmlApplicationContext("spring/beans.xml"); //或者ApplicationContext ctx = new FileSystemXmlApplicationContext("spring/beans.xml"); 在获取ApplicationContext实例后，就可以像BeanFactory一样调用getBean(beanName)返回Bean了。需要注意的是：ApplicationContext在初始化应用上下文时就实例化所有单实例的Bean。因此，相比BeanFactory，初始化时间也会相对较长些，不过之后的调用就不在有“第一次惩罚”的问题。 3.3 WebApplicationContextWebApplicationContext是专门为Web应用准备的，它允许应用从相对于Web根目录的路径中装载配置文件完成初始化工作。从WebApplicationContext中可以获得ServletContext的引用，整个Web应用上下文对象将作为属性放置到ServletContext中，以便Web应用环境可以访问Spring应用上下文。 WebApplicationContext的初始化方式和BeanFactory、ApplicationContext有所区别，因为WebApplicationContext需要ServletContext实例，也就是说它必须在拥有Web容器的前提下才能完成启动的工作。有过Web开发经验的读者都知道可以在web.xml中配置自启动的Servlet(spring3.0及以后版本中已经删除)或定义Web容器监听器（ServletContextListener），借助这两者中的任何一个都可以完成启动Spring Web应用上下文的工作。通过web容器监听器启动：web.xml 1234567891011&lt;context-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt; classpath:/spring/spring-context.xml &lt;/param-value&gt;&lt;/context-param&gt;&lt;!-- spring容器启动监听器 --&gt;&lt;listener&gt; &lt;listener-class&gt;org.springframework.web.context.ContextLoaderListener&lt;/listener-class&gt;&lt;/listener&gt; 4、Bean的生命周期4.1 BeanFactory中Bean的生命周期我们知道Web容器中的Servlet拥有明确的生命周期，Spring容器中的Bean也拥有相似的生命周期。我们可以从两个层面定义Bean的生命周期：第一个层面是Bean的作用范围；第二个层面是实例化Bean时所经历的一系列阶段。 当调用者通过getBean(beanName)向容器请求某一个Bean时，如果容器注册了org.springframework.beans.factory.config.InstantiationAwareBeanPostProcessor接口，在实例化Bean之前，将调用接口的postProcessBeforeInstantiation()方法; 根据配置情况调用Bean构造函数或工厂方法实例化Bean； 如果容器注册了InstantiationAwareBeanPostProcessor接口，在实例化Bean之后，调用该接口的postProcessAfterInstantiationn()方法，可以在这里对已经实例化的对象进行处理。 如果Bean配置了属性信息，容器在这一步着手将配置值设置到Bean对应的属性中，不过在设置每个属性值之前先调用InstantiationAwareBeanPostProcessor接口的postProcessPropertyValues()方法； 调用Bean的属性设置方法设置属性值； 如果Bean实现了org.springframework.beans.factory.BeanNameAware接口，将调用setBeanName()接口方法，将配置文件中该Bean对应的名称设置到Bean中； 如果Bean实现了org.springframework.bean.factory.BeanFactoryAware接口，将调用setBeanFactory()接口方法，将BeanFactory容器实例设置到Bean中； 如果BeanFactory装配了org.springframework.beans.factory.config.BeanPostProcessor后处理器，将调用BeanPostProcessor的Object postProcessBeforeInstantiation(Object bean, Stringn beanName)接口方法对Bean进行加工操作。其中入参bean是当前正在处理的Bean，而beanName是当前Bean的配置名，返回的对象为加工处理后的Bean。BeanPostProcessor在Spring框架中占有重要的地位，为容器提供duiBean进行后续架构处理的切入点，Spring容器所提供的各种“神奇功能”（如AOP，动态代理等）都通过BeanPostProcessor实施； 如果Bean实现了InitializingBean的接口，将调用该接口的afterPropertiesSet()方法； 如果在通过init-method属性定义了初始化方法，将执行这个方法； BeanPostProcessor后处理定义了两个方法：其一时postProcessBeforeInstantiation()在第8步调用；其二是Object postProcessAfterInstantiationn(Object bean, String beanName)方法，这个方法在此时调用，容器中再次获得对Bean进行加工处理的机会。 如果在中指定Bean的作用范围是scope=”prototype”，将Bean返回给调用者，调用者负责Bean后续生命的管理，Spring不再管理这个Bean的生命周期。如果作用范围设置为scope=“singleton”，则将Bean放入到Spring IoC容器的缓存池中，并将Bean引用返回给调用者，Spring继续对这些Bean进行后续的生命管理。 对于scope=“singleton”的Bean，当容器关闭时，将触发Spring对Bean的后续生命周期的管理工作，首先如果Bean实现了DisposableBean接口，则将调用接口的afterPropertiesSet()方法，可以在此编写释放资源、记录日志等操作。 对于scope=“singleton”的Bean，如果通过的destroy-method属性指定了Bean的销毁方法，Spring将执行Bean的这个方法，完成Bean资源的释放等操作。 Bean生命周期实例：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184public class Car implements BeanFactoryAware, BeanNameAware, InitializingBean, DisposableBean &#123; private String brand; private String color; private int maxSpeed; private BeanFactory beanFactory; private String beanName; public Car() &#123; System.out.println("调用Car()构造函数。"); &#125; public Car(String brand, String color, int maxSpeed) &#123; this.brand = brand; this.color = color; this.maxSpeed = maxSpeed; &#125; public void introduce() &#123; System.out.println("brand:" + brand + ";color:" + color + ";maxSpeed:" + maxSpeed); &#125; public String getBrand() &#123; return brand; &#125; public void setBrand(String brand) &#123; System.out.println("调用setBrand()设置属性。"); this.brand = brand; &#125; public String getColor() &#123; return color; &#125; public void setColor(String color) &#123; this.color = color; &#125; public int getMaxSpeed() &#123; return maxSpeed; &#125; public void setMaxSpeed(int maxSpeed) &#123; this.maxSpeed = maxSpeed; &#125; // 5 DisposableBean方法 @Override public void destroy() throws Exception &#123; System.out.println("调用DisposaleBean.destroy()。"); &#125; // 4 IntializingBean接口方法 @Override public void afterPropertiesSet() throws Exception &#123; System.out.println("调用IntializingBean.afterPropertiesSet()。"); &#125; // 3 BeanNameAware接口方法 @Override public void setBeanName(String name) &#123; System.out.println("调用BeanNameAware.setBeanName()。"); this.beanName = beanName; &#125; // 2 BeanFactoryAware接口方法 @Override public void setBeanFactory(BeanFactory beanFactory) throws BeansException &#123; System.out.println("调用BeanFactoryAware.setBeanFactory()。"); this.beanFactory = beanFactory; &#125; // 6 通过&lt;bean&gt;的init-method属性指定的初始化方法 public void myInit() &#123; System.out.println("调用init-method所指定的myInit()，将maxSpeed设置为240。"); this.maxSpeed = 240; &#125; // 7 通过&lt;bean&gt;的destroy-method属性指定的销毁方法 public void myDestroy() &#123; System.out.println("调用destroy-method所指定的myDestroy()。"); &#125;&#125;public class MyInstantiationAwareBeanPostProcessor extends InstantiationAwareBeanPostProcessorAdapter &#123; // 1 在实例化Bean前进行调用 public Object postProcessBeforeInitialization(Class beanClass, String beanName) throws BeansException &#123; // 1-1 仅对容器中Car Bean进行处理 if ("car".equals(beanName)) &#123; System.out.println("InstantiationAware BeanPostProcessor.postProcessBeforeInstantiation"); &#125; return null; &#125; // 2 在实例化Bean后调用 public boolean postProcessAfterInstantiation(Object bean, String beanName) &#123; // 2-1 仅对容器中Car Bean进行处理 if ("car".equals(beanName)) &#123; System.out.println("InstantiationAware BeanPostProcessor.postProcessAfterInstantiation"); &#125; return true; &#125; // 3 在设置某个属性时调用 public PropertyValues postProcessPropertyValues(PropertyValues pvs, PropertyDescriptor[] pds, Object bean, String beanName) throws BeansException &#123; // 3-1 仅对容器中Car Bean进行处理,还可以通过pdst入参进行过滤，仅对car的某个特定属性时进行处理 if("car".equals(beanName)) &#123; System.out.println("InstantiationAware AwareBeanPostProcessor.postProcessPropertyValues"); &#125; return pvs; &#125;&#125;public class MyBeanPostProcessor implements BeanPostProcessor &#123; @Override public Object postProcessBeforeInitialization(Object bean, String beanName) throws BeansException &#123; if(beanName.equals("car")) &#123; Car car = (Car)bean; if(car.getColor() == null) &#123; System.out.println("调用BeanPostProcessor.postProcessBeforeInitialization(),color为空，设置为默认黑色。"); car.setColor("黑色"); &#125; &#125; return bean; &#125; @Override public Object postProcessAfterInitialization(Object bean, String beanName) throws BeansException &#123; if(beanName.equals("car")) &#123; Car car = (Car)bean; if(car.getMaxSpeed() &gt;= 200) &#123; System.out.println("调用BeanPostProcessor.postProcess AfterInitialization(), 将maxSpeed调整为200。"); car.setMaxSpeed(200); &#125; &#125; return bean; &#125;&#125;**beans.xml**&lt;?xml version="1.0" encoding="UTF-8" ?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:p="http://www.springframework.org/schema/p" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-3.0.xsd"&gt; &lt;bean id="car" class="com.hhxs.bbt.web.Car" init-method="myInit" destroy-method="myDestroy" p:brand="红旗CA72" p:maxSpeed="200" scope="singleton" /&gt;&lt;/beans&gt;public class BeanLifeCycle &#123; private static void lifeCycleInBeanFactory() &#123; Resource res = new ClassPathResource("spring/beans.xml"); BeanFactory bf = new XmlBeanFactory(res); // 向容器中注册后处理器 ((ConfigurableBeanFactory)bf).addBeanPostProcessor(new MyBeanPostProcessor()); ((ConfigurableBeanFactory)bf).addBeanPostProcessor(new MyInstantiationAwareBeanPostProcessor()); // 第一次从容器中获取Car，将触发容器实例化该Bean,这将引发Bean生命周期方法的调用。 Car car1 = (Car)bf.getBean("car"); car1.introduce(); car1.setColor("红色"); car1.introduce(); // 第二次从容器中获取Car，直接从缓存池中获取 Car car2 = (Car)bf.getBean("car"); // 查看car1和car2是否指向同一引用 System.out.println("car1==car2:" + (car1==car2)); // 关闭容器 ((XmlBeanFactory)bf).destroySingletons(); &#125; public static void main(String[] args) &#123; lifeCycleInBeanFactory(); &#125;&#125; 运行上述代码，我们在控制台上得到以下输出信息，仔细观察，将发现它验证了我们前面所介绍的Bean生命周期过程。123456789101112131415调用Car()构造函数。InstantiationAware BeanPostProcessor.postProcessAfterInstantiationInstantiationAware AwareBeanPostProcessor.postProcessPropertyValues调用setBrand()设置属性。调用BeanNameAware.setBeanName()。调用BeanFactoryAware.setBeanFactory()。调用BeanPostProcessor.postProcessBeforeInitialization(),color为空，设置为默认黑色。调用IntializingBean.afterPropertiesSet()。调用init-method所指定的myInit()，将maxSpeed设置为240。调用BeanPostProcessor.postProcess AfterInitialization(), 将maxSpeed调整为200。brand:红旗CA72;color:黑色;maxSpeed:200brand:红旗CA72;color:红色;maxSpeed:200car1==car2:true调用DisposaleBean.destroy()。调用destroy-method所指定的myDestroy()。 4.2 ApplicationContext中Bean的生命周期Bean在应用上下文中的生命周期和BeanFactory中生命周期类似，不同的是，如果Bean实现org.springframework.context.ApplicationContextAware接口，会增加一个调用该接口方法setApplicationContext()的步骤。 此外，如果配置文件中声明了工作后处理器接口BeanFactoryPostProcessor的实现类，则应用上下文在装载配置文件之后初始化Bean实例之前将调用这些BeanFactoryPostProcessor对配置信息进行加工处理。工厂后处理器是容器级的，仅在应用上下文初始化时调用一次，其目的是完成一些配置文件的加工处理工作。 ApplicationContext和BeanFactory另一最大的不同之处在于：前者会利用Java反射机制自动识别出配置文件中定义的BeanPostProcessor、InstantiationAwareBeanPostProcessor和BeanFactoryPostProcessor，并自动将它们注册到应用上下文中；而后者需要在代码中拿你给通过手工调用addBeanPostProcessor()方法进行注册。这也是为什么在应用开发室，我们普遍使用ApplicationContext而很少使用BeanFactory的原因之一。]]></content>
      <categories>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>IoC</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Activiti工作流之项目中的使用]]></title>
    <url>%2F2017%2F10%2F19%2FActiviti%E5%B7%A5%E4%BD%9C%E6%B5%81%E5%AD%A6%E4%B9%A02%2F</url>
    <content type="text"><![CDATA[Activiti工作流特点的其中之一就是原生支持Spring。前一章节我们介绍了Activit工作流的基本概念，让大家对工作流知识有了一个大体的印象，这一节我们说下在项目中的使用。 1、Spring集成首先在Maven中将Spring集成包引入进来。12345&lt;dependency&gt; &lt;groupId&gt;org.activiti&lt;/groupId&gt; &lt;artifactId&gt;activiti-spring&lt;/artifactId&gt; &lt;version&gt;5.22.0&lt;&lt;/version&gt;&lt;/dependency&gt; 可以把流程引擎（ProcessEngine）作为一个普通的Springbean进行配置。类org.activiti.spring.ProcessEngineFactoryBean是集成的切入点,这个bean需要一个流程引擎配置来创建流程引擎。 1234567891011121314151617&lt;!-- activiti config --&gt;&lt;bean id="processEngineConfiguration" class="org.activiti.spring.SpringProcessEngineConfiguration"&gt; &lt;property name="databaseType" value="oracle" /&gt; &lt;property name="dataSource" ref="dataSource" /&gt; &lt;property name="transactionManager" ref="transactionManager" /&gt; &lt;property name="databaseSchemaUpdate" value="true" /&gt;&lt;/bean&gt;&lt;bean id="processEngine" class="org.activiti.spring.ProcessEngineFactoryBean"&gt; &lt;property name="processEngineConfiguration" ref="processEngineConfiguration" /&gt;&lt;/bean&gt;&lt;bean id="repositoryService" factory-bean="processEngine" factory-method="getRepositoryService" /&gt;&lt;bean id="runtimeService" factory-bean="processEngine" factory-method="getRuntimeService" /&gt;&lt;bean id="taskService" factory-bean="processEngine" factory-method="getTaskService" /&gt;&lt;bean id="historyService" factory-bean="processEngine" factory-method="getHistoryService" /&gt;&lt;bean id="managementService" factory-bean="processEngine" factory-method="getManagementService" /&gt;z 其中datasource是指项目中配置的数据源，transactionManager是指项目中配置的事务管理器配置。如下： 123456789101112131415161718192021222324252627282930313233343536373839&lt;!-- 数据源配置 --&gt;&lt;bean id="dataSource" class="com.alibaba.druid.pool.DruidDataSource" init-method="init" destroy-method="close"&gt; &lt;!-- 基本属性 url、user、password --&gt; &lt;property name="driverClassName" value="$&#123;jdbc.driver&#125;" /&gt; &lt;property name="url" value="$&#123;jdbc.url&#125;" /&gt; &lt;property name="username" value="$&#123;jdbc.username&#125;" /&gt; &lt;property name="password" value="$&#123;jdbc.password&#125;" /&gt; &lt;!-- 配置初始化大小、最小、最大 --&gt; &lt;property name="initialSize" value="$&#123;jdbc.pool.initialSize&#125;" /&gt; &lt;property name="minIdle" value="$&#123;jdbc.pool.minIdle&#125;" /&gt; &lt;property name="maxActive" value="$&#123;jdbc.pool.maxActive&#125;" /&gt; &lt;!-- 配置获取连接等待超时的时间 --&gt; &lt;property name="maxWait" value="60000" /&gt; &lt;!-- 配置间隔多久才进行一次检测，检测需要关闭的空闲连接，单位是毫秒 --&gt; &lt;property name="timeBetweenEvictionRunsMillis" value="30000" /&gt; &lt;!-- 配置一个连接在池中最小生存的时间，单位是毫秒 --&gt; &lt;property name="minEvictableIdleTimeMillis" value="300000" /&gt; &lt;property name="validationQuery" value="SELECT 'x' from dual" /&gt; &lt;property name="testWhileIdle" value="true" /&gt; &lt;property name="testOnBorrow" value="false" /&gt; &lt;property name="testOnReturn" value="false" /&gt; &lt;!-- 打开PSCache，并且指定每个连接上PSCache的大小（Oracle使用） --&gt; &lt;property name="poolPreparedStatements" value="true" /&gt; &lt;property name="maxPoolPreparedStatementPerConnectionSize"value="20" /&gt; &lt;!-- 配置监控统计拦截的filters，去掉后监控界面sql无法统计 --&gt; &lt;property name="filters" value="stat" /&gt;&lt;/bean&gt;&lt;!-- 事务管理器配置,单数据源事务 --&gt;&lt;bean id="transactionManager" class="org.springframework.jdbc.datasource.DataSourceTransactionManager"&gt; &lt;property name="dataSource" ref="dataSource" /&gt;&lt;/bean&gt; 至此，集成成功，像使用一般bean对象的方式使用Activit对象即可。 2、基础API介绍项目里用到的基本都是顺序流，没有用到网关，所以在这里不会介绍网关的东西，只介绍项目用到相关知识。 2.1 七项基本操作 设计流程图（各种组件，如连线、用户任务、网关） 流程定义增删改查 流程变量增删改查 启动流程定义 任务增删改查 完成任务 历史信息查询 上面列举了Activiti中用到的七项操作种类，每一种操作都有着对应的API，需要用到哪些API请查看官网文档，或者Google，这里不再赘述。 2.2 常用操作2.2.1 使用Eclipse开始流程设计Eclipse插件安装请参照Activiti工作流之基础概念介绍 鼠标选中要新建流程图的文件夹，点击右键，选择new-&gt;others-&gt;Activiti Diagram，即可新建一个图表。记得要把Eclipse切换到Activit视图，一个简单的流程图类似下图，只需要关注红框里的元件就可以了，如果复杂的就需要用到其它元件了，比如网关。可以自行拖拽试试，网上这部分操作知识很多，这里不再赘述。 2.2.1 工作流部署其中recourceClassPath表示工作流相对项目classpath下的路径，例如maven项目中src/main/resource下的”bpmn/HelloWorldProcess.bpmn“。resourceName表示你要部署工作流的名称，这个名称一般用来说明工作流的作用，比如“请假流程“。12345public Deployment deployProcess(String resourceClassPath, String resourceName) &#123; Deployment deployMent = repositoryService.createDeployment().name(resourceName) .addClasspathResource(resourceClassPath).deploy(); return deployMent;&#125; 每重复部署一次，act_re_deployment表中新增加的记录的ID值都会随之增大，相应流程启动的时候取得是最新的值，也就是最大的值。如果想避免重复部署，可以使用下面的方式：123456public Deployment deployProcess(String resourceClassPath, String resourceName) &#123; //过滤关键是为流程部署起一个名字`fileName`，没有名字不会过滤 Deployment deployMent = repositoryService.createDeployment().enableDuplicateFiltering().name(fileName) .name(resourceName).addClasspathResource(resourceClassPath).deploy(); return deployMent;&#125; 2.2.2 流程启动其中procDefkey表示流程定义key, businessKey表示业务key, processVariables表示流程执行过程中需要的变量。123456789public ProcessInstance startProcessInstance(String procDefKey, String businessKey, Map&lt;String, Object&gt; processVariables) &#123; // 根据流程定义KEY查询最新版本的流程定义 ProcessDefinitionEntity procDef = (ProcessDefinitionEntity) getProcessDefinitionByKey(procDefKey); if (procDef == null) &#123; throw new RuntimeException("流程定义KEY为" + procDefKey + "流程定义未找到，请重新发布"); &#125; return runtimeService.startProcessInstanceByKey(procDefKey, businessKey, processVariables);&#125; 2.2.3 任务完成其中taskId表示要完成的任务ID,variables表示流程变量123456private void commitProcess(String taskId, Map&lt;String, Object&gt; variables) &#123; if (variables == null) &#123; variables = new HashMap&lt;String, Object&gt;(); &#125; taskService.complete(taskId, variables); &#125; 2.2.4 流程跳转这里只说明主要算法，其中taskId表示任务ID，activityId表示待跳转的“活动节点Id”123456789101112131415161718private void commitProcess(String taskId, String activityId) &#123; // 当前节点 ActivityImpl currActivity = findActivitiImpl(taskId, null); // 清空当前流向 List&lt;PvmTransition&gt; oriPvmTransitionList = clearTransition(currActivity); // 创建新流向 TransitionImpl newTransition = currActivity.createOutgoingTransition(); // 目标节点 ActivityImpl pointActivity = findActivitiImpl(taskId, activityId); // 设置新流向的目标节点 newTransition.setDestination(pointActivity); // 提交任务 taskService.complete(taskId, variables); // 删除目标节点新流入 pointActivity.getIncomingTransitions().remove(newTransition); // 还原以前流向 restoreTransition(currActivity, oriPvmTransitionList); &#125; 2.2.4 流程终止其中procId表示流程实例ID12345678public void terminateByBillCode(String procId) &#123; try &#123; // 终止流程 runtimeService.deleteProcessInstance(procId, "删除原因"); &#125; catch (Throwable e) &#123; LOG.error("终止流程By业务单号-controller" + e.getMessage(), e); &#125;&#125; 2.2.5 工作流删除其中deploymentId表示工作流部署ID，这个方法一般很少使用，新工作流启动时会自动选择最新部署的工作流。如果工作流需要更新，只需要重新部署工作就即可。1234567public void deleteDeployment(String deploymentId) throws Exception &#123; RepositoryService repositoryService = processEngine.getRepositoryService(); // 普通删除，如果当前规则下有正在执行的流程，则抛出异常 //repositoryService.deleteDeployment(deploymentId); // 级联删除，会删除和当前规则相关的所有信息，正在执行的信息，也包括历史信息 repositoryService.deleteDeployment(deploymentId,true);&#125; 2.3 集成自己的用户管理系统Activiti自带的用户权限管理系统功能不够强大，而一般业务系统都有自己的用户管理平台，你可以选择以某种方式来同步两者之间的用户信息，也可以直接使用业务系统的用户管理平台作为工作流权限管理。下面说下思路： 新建一个中间表比如ACT_PROC_CONFIG,字段包括流程key/角色ID/组织ID/用户ID。 提供一个页面用于设置对每个工作流进行设置，分别将各环节的任务分配给某个部门中的某个角色的某些人员。这样就将自己的用户管理平台和Activiti工作流有效集成起来了。 针对工作流编写业务代码的时候，将ACT_PROC_CONFIG表融进来，比如判断某个用户是否有当前任务的处理权限，下一环节任务有哪些人员可以处理等。 2.4 流程定制一般情况下，工作流部署以后流程就是固定的。具体每个用户任务可以根据业务需要提前设置好相应的部门处理人员，这样当执行到某个用户任务的时候，自然会有满足条件的人员可以处理。但是也有特殊情况，比如走到某个用户任务的时候，要根据当前的实际工作来判断后面的流程还需不需要走，还需要哪些流程处理，哪些流程可以跳过，哪些流程我想指定某个人来处理，这就牵扯到流程定制的问题。而这些功能基本上都是需要结合流程变量自己编码实现的。需要根据实际的业务自行设计，主要就是用到了流程变量和流程跳转功能，业务不同设计也不同，这里也不再讲述，只是说明一种应用场景。 2.5、资源的自动部署Spring的集成也有一个专门用于对资源部署的特性。在流程引擎的配置中，你可以指定一组资源。当流程引擎被创建的时候， 所有在这里的资源都将会被自动扫描与部署。在这里有过滤以防止资源重新部署，只有当这个资源真正发生改变的时候，它才会向Activiti使用的数据库创建新的部署。 这对于很多用例来说，当Spring容器经常重启的情况下（例如 测试），使用它是非常不错的选择。这里有一个例子：12345678&lt;bean id="processEngineConfiguration" class="org.activiti.spring.SpringProcessEngineConfiguration"&gt; ... &lt;property name="deploymentResources" value="classpath*:/activiti/*.bpmn" /&gt;&lt;/bean&gt;&lt;bean id="processEngine" class="org.activiti.spring.ProcessEngineFactoryBean"&gt; &lt;property name="processEngineConfiguration" ref="processEngineConfiguration" /&gt;&lt;/bean&gt; 默认，上面的配置会把所有匹配的资Activiti引擎的一个单独发布包下。用来检测防止未修改资源重复发布的机制会作用到整个发布包中。 有时候，这可能不是你想要的。比如，如果你发布了很多流程资源，但是只修改里其中某一个单独的流程定义， 整个发布包都会被认为变更了，导致整个发布包下的所有流程定义都会被重新发布， 结果就是每个流程定义都生成了新版本，虽然其中只有一个流程发生了改变。 为了定制发布方式，你可以为SpringProcessEngineConfiguration指定一个额外的参数deploymentMode。 这个参数指定了匹配多个资源时的发布处理方式。默认下这个参数支持设置三个值： default: 把所有资源放在一个单独的发布包中，对这个发布包进行重复检测。 这是默认值，如果你没有指定参数值，就会使用它。 single-resource: 为每个单独的资源创建一个发布包，并对这些发布包进行重复检测。 你可以单独发布每个流程定义，并在修改流程定义后只创建一个新的流程定义版本。 resource-parent-folder: 把放在同一个上级目录下的资源发布在一个单独的发布包中，并对发布包进行重复检测。 当需要多资源需要创建发布包，但是需要根据共同的文件夹来组合一些资源时，可以使用它。 12345&lt;bean id="processEngineConfiguration" class="org.activiti.spring.SpringProcessEngineConfiguration"&gt; ... &lt;property name="deploymentResources" value="classpath*:/activiti/*.bpmn" /&gt; &lt;property name="deploymentMode" value="single-resource" /&gt;&lt;/bean&gt; 项目中虽然没用到工作流的网关等功能，但是因为项目中的流程定制业务较多，加上实际使用场景要考虑很多问题，实际使用时还是蛮复杂的。这还需要在实际项目中历练，才能更加清晰掌握工作流的使用。但是如果只是想要简单的入门，找几个例子学习下就可以了。]]></content>
      <categories>
        <category>Activiti工作流</category>
      </categories>
      <tags>
        <tag>Activiti</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Activiti工作流之基础概念介绍]]></title>
    <url>%2F2017%2F10%2F13%2FActiviti%E5%B7%A5%E4%BD%9C%E6%B5%81%E5%AD%A6%E4%B9%A01%2F</url>
    <content type="text"><![CDATA[自我驱动力的来源是刚需。 前段时间从另外一个团队手里接过来一个半成品项目，是一个工作流系统。半成品就算了，还要快速完成工作任务，说多了都是泪，算是接了一个大锅。为了快速上手Activiti工作流的使用，基本上是边学习变实践，因此整个项目做下来对工作流知识依然处于比较散乱的阶段，趁着项目暂时告一段落把知识梳理下。言归正传，下面进入正题： 1、基本概念 工作流：业务过程的部分或整体在计算机应用环境下的自动化 工作流管理系统：工作流的定义和管理，按照在系统中预定义好的工作流规则进行工作流实例的执行。 工作流管理系统的目标：管理工作流程以确保工作在正确的时间被期望的人员执行–在自动化进行的业务过程中插入人工的执行和干预。 Activiy是什么 Activiti是一个针对企业用户、开发人员、系统管理员的轻量级工作流业务管理平台，其核心是使用Java开发的快速、稳定的BPMN2.0流程引擎。 Activiti的特点 数据持久化，底层使用MyBatis 引擎Service接口 流程设计器 原生支持Spring 分离运行时与历史数据 2、核心表介绍2.1 理解数据库表的命名Activiti的表都以ACT_开头。第二部分表示表的用途的两个字母标识。用途也和服务的API对应。 ACTRE*:’RE’表示repository。这个前缀的表包含了流程定义和流程静态资源（图片、规则，等等） ACTRU*: ‘RU’表示rutime。这些运行时的表，包含流程实例、任务、变量、异步任务，等运行中的数据。Activiti只在流程实例执行过程中保存这些数据，在流程结束时就会删除这些记录。这样可以保证运行时表可以一直很小且速度很快。 ACTID*’ID’表示identity。这些表包含身份信息，比如用户，组等等。 ACTHI*:’HI’表示history。这些表包含历史数据，比如历史流程实例、变量、任务等等。 ACTGE*: 通用数据，用于不同场景下。 2.2 表用途介绍通用数据表: ACT_GE_BYTEARRAY: 存储部署流程的二进制数据，一个流程包括一个工作流信息和一张对应的工作流图片。ACT_GE_PROPERTY: 存储整个流程引擎级别的数据，用于部署流程时获取新的版本号，初始化表结构时，会默认插入三条记录 历史数据库表: ACT_HI_ACTINST: 存储历史活动节点数据ACT_HI_ATTACHMENT: 存储历史附件数据ACT_HI_COMMENT: 存储历史评论数据或者事件数据ACT_HI_DETAIL: 存储历史流程变量详情信息ACT_HI_IDENTITYLINK: 存储历史流程人员操作信息ACT_HI_PROCINST: 存储历史流程实例信息ACT_HI_TASKINST: 存储历史任务实例信息ACT_HI_VARINST: 存储历史流程变量信息 用户组织表: ACT_ID_GROUP: 存储用户组信息ACT_ID_INFO: 存储用户扩展信息ACT_ID_MEMBERSHIP: 存储用户与用户组队形信息ACT_ID_USER: 存储用户信息 工作流流程规则表: ACT_RE_DEPLOYMENT: 存储工作流部署信息，比如工作流名称等ACT_RE_MODEL: 存储流程设计模型信息ACT_RE_PROCDEF: 存储流程定义数据 运行时数据表: ACT_RU_EVENT_SUBSCR: 如果流程到达某个事件节点，Activiti会往该表中加入事件描述数据，这些事件描述数据将会决定流程事件的触发。ACT_RU_EXECUTION: 存储运行时流程执行实例信息ACT_RU_IDENTITYLINK: 存储运行时流程人员操作信息，主要存储任务节点与参与者的相关信息ACT_RU_JOB: 存储运行时定时任务信息ACT_RU_TASK: 存储运行时任务节点信息ACT_RU_VARIABLE: 存储运行时流程变量信息 其他: CT_EVT_LOG: 存储事件日志信息ACT_PROCDEF_INFO: 存储流程定义的动态变更信息 3、核心概念介绍3.1 核心API ProcessEngine: 在Activiti中最核心的类 ProcessDefinition: 流程定义类。可以从这里获得资源文件等。 ProcessInstance: 代表流程定义的执行实例，一个流程实例包括了所有的运行节点。我们可以利用这个对象来了解当前流程实例的进度等信息，一个流程实例就表示一个流程从刚开始到结束的最大流程分支，即一个流程中流程实例只有一个。 Execution: Activiti用这个对象去描述流程执行的每一个节点。在没有并发的条件下，Execution就是同ProcessInstance。流程按照流程定义的规则执行一次的过程，就可以表示执行对象Execution。 一个流程中，执行对象可以存在多个，但是流程实例只能有一个。 当流程按照规则只执行一次的时候，那么流程实例就是执行对象。 Task: 执行到某任务环节时生成的任务信息。 由于数据库中保存着历史信息以及正在运行的流程实例信息，在实际项目中对已完成任务的查看频率远不及对代办和可接任务的查看，所以在activiti采用分开管理，把正在运行的交给RuntimeService、TaskService管理，而历史数据交给HistoryService来管理。 流程变量: 在流程执行或者任务执行的过程中，用于设置和获取变量，使用流程变量在流程传递的过程中传递业务参数。 3.2 七大Service接口 RepositoryService: 仓库服务类，管理流程定义。用于管理流程仓库，例如部署、删除、读取流程资源。所谓的仓库指流程定义文档的两个文件：bpmn文件和流程图片。 IdentifyService: 身份Service，用户管理和查询用户、组之间的关系 RuntimeService: 流程执行服务类，可以从这个服务类中获取很多关于流程执行相关的信息。 TaskService: 任务服务类，可以从这个类中获取任务的信息。 FormService: 表单Servcie，用于读取流程、任务相关的表单数据。 HistoryService: 查询历史信息的类，在一个流程执行完成后，这个对象为我们提供查询历史信息，例如流程实例、任务、活动、变量、附件。 ManagementService引擎管理Service，和具体业务无关，主要可以查询引擎配置、数据库、作业等。 学习知识最好先对基础的概念有个初步的认识，这方便在后续的学习过程中更好的理解这些概念。在对Activiti有了初步的印象后，下面通过在使用的过程中进一步熟悉Activiti工作流。 4、开始使用Activiti默认使用自带的H2内存数据库，而实际生产环境中使用Oracle或mysql居多，这里配置为oracle数据库。 4.1 在项目里引入相关jar这里将Spring集成包也引入进来了，这是生产环境常用的使用方式。不需要的可以将activiti-spring引用包去掉。123456789101112131415&lt;dependency&gt; &lt;groupId&gt;org.activiti&lt;/groupId&gt; &lt;artifactId&gt;activiti-engine&lt;/artifactId&gt; &lt;version&gt;5.22.0&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.activiti&lt;/groupId&gt; &lt;artifactId&gt;activiti-spring&lt;/artifactId&gt; &lt;version&gt;5.22.0&lt;&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.slf4j&lt;/groupId&gt; &lt;artifactId&gt;slf4j-api&lt;/artifactId&gt; &lt;version&gt;1.7.6&lt;/version&gt;&lt;/dependency&gt; 4.2 安装Activiti数据库Activiti框架拥有自动建表功能，在创建流程引擎对象的时候会在数据库中自动创建表。 4.2.1 不使用配置文件测试代码：12345678910public void intiProcessEngine() &#123; // 获取流程引擎 ProcessEngine processEngine = new StandaloneProcessEngineConfiguration() .setJdbcUrl("jdbc:oracle:thin:@172.16.58.17:1521:orcl") .setJdbcUsername("activiti") .setJdbcPassword("111111") .setJdbcDriver("oracle.jdbc.driver.OracleDriver") .setDatabaseSchemaUpdate(ProcessEngineConfiguration.DB_SCHEMA_UPDATE_TRUE) .buildProcessEngine(); &#125; 4.2.2 使用activiti.cfg.xml配置文件在classpath下创建activiti.cfg.xml配置文件（名称随意，只要能访问到即可），内容如下：123456789101112131415161718192021222324252627282930313233&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:context="http://www.springframework.org/schema/context" xmlns:tx="http://www.springframework.org/schema/tx" xmlns:jee="http://www.springframework.org/schema/jee" xmlns:aop="http://www.springframework.org/schema/aop" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-3.0.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-3.0.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx-3.0.xsd http://www.springframework.org/schema/jee http://www.springframework.org/schema/jee/spring-jee-3.0.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop-3.0.xsd"&gt; &lt;!-- 配置流程引擎配置对象 --&gt; &lt;bean id="processEngineConfiguration" class="org.activiti.engine.impl.cfg.StandaloneProcessEngineConfiguration"&gt; &lt;property name="jdbcUrl" value="jdbc:oracle:thin:@172.16.58.17:1521:orcl"/&gt; &lt;property name="jdbcDriver" value="oracle.jdbc.driver.OracleDriver" /&gt; &lt;property name="jdbcUsername" value="activiti" /&gt; &lt;property name="jdbcPassword" value="111111" /&gt; &lt;property name="databaseSchemaUpdate" value="true" /&gt; &lt;property name="jobExecutorActivate" value="false" /&gt; &lt;/bean&gt; &lt;bean id="processEngine" class="org.activiti.spring.ProcessEngineFactoryBean"&gt; &lt;property name="processEngineConfiguration" ref="processEngineConfiguration" /&gt; &lt;/bean&gt; &lt;bean id="repositoryService" factory-bean="processEngine" factory-method="getRepositoryService" /&gt; &lt;bean id="runtimeService" factory-bean="processEngine" factory-method="getRuntimeService" /&gt; &lt;bean id="taskService" factory-bean="processEngine" factory-method="getTaskService" /&gt; &lt;bean id="formService" factory-bean="processEngine" factory-method="getFormService" /&gt; &lt;bean id="historyService" factory-bean="processEngine" factory-method="getHistoryService" /&gt; &lt;bean id="managementService" factory-bean="processEngine" factory-method="getManagementService" /&gt; &lt;bean id="identityService" factory-bean="processEngine" factory-method="getIdentityService" /&gt;&lt;/beans&gt; 测试代码：12345public void intiProcessEngine() &#123; // 获取流程引擎 ProcessEngineConfiguration pec = ProcessEngineConfiguration.createProcessEngineConfigurationFromResource("activiti.cfg.xml"); processEngine = pec.buildProcessEngine();&#125; 4.2.3 使用默认配置文件配置文件要求配置文件名称必须为activiti-context.xml或者activiti.cfg.xml因为,因为默认的配置ProcessEngines.getDefaultProcessEngine();会初始化这两个文件的其中一个. 测试代码：123public void intiProcessEngine() &#123; ProcessEngine processEngine =ProcessEngines.getDefaultProcessEngine();&#125; 4.3 开发环境搭建|Eclipse插件安装 通过网址：[https://www.activiti.org/designer/archived/activiti-designer-5.18.0.zip] 下载离线安装包。 将离线安装包解压缩，将包中的内容放入eclipse根目录的dropins文件夹下，重启eclipse。 安装成功后，打开菜单Preferences-&gt;Activiti-&gt;Save Action，勾选流程图片的生成方式为当保存流程设计图时。]]></content>
      <categories>
        <category>Activiti工作流</category>
      </categories>
      <tags>
        <tag>Activiti</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用Hexo在Github上搭建个人Blog]]></title>
    <url>%2F2017%2F09%2F21%2F%E4%BD%BF%E7%94%A8Hexo%E5%9C%A8Github%E4%B8%8A%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E7%BD%91%E7%AB%99%2F</url>
    <content type="text"><![CDATA[亲手创造的东西总会带给自己无以言表的喜悦，而且也会让你更加珍惜。想知道这个博客是怎么来的吗？下面就给大家展示下这个博客的创建过程。 在开始之前，你必须要有一个Github账号,如果还没有请去官网注册Github。另外，确认本地已经安装好git和npm,如果没有请访问Hexo官网，官网上有对Hexo安装及使用的详细介绍，包括git和npm的安装指导。这里只介绍Blog搭建过程。 1.Github PagesGithub Pages是一个静态站点托管服务，可以把Github repository里的个人站点页面直接托管到上面。 在浏览器中登录 Github，创建一个Repo，名称格式为yourname.github.io（注意必须要以github.io结尾） 2.安装Hexo再确认本地安装了git和npm后，Terminal里输入：12npm install -g hexonpm install -g hexo-cli 3.初始化本地站点123hexo init &lt;folder&gt;cd &lt;folder&gt;npm instll &lt;folder&gt;是你建立的文件夹名称，我这里是zqhao.github.io 继续在Terminal里执行12hexo generatehexo server hexo server 开启本地服务，浏览器中敲入http://localhost:4000/ 看看网站初始的样子。 4.关联GithubTerminal cd到&lt;folder&gt;下，使用vim命令打开_config.yml，我这里使用的Atom编辑器。找到deploy那一部分，改成：123deploy： type: git repo: https://github.com/yourname/yourname.github.io.git 其中：yourname，改成你的Github用户名，repo对应的地址在第1步建仓库的地方获取。 注意：在配置所有的_config.yml文件时，在所有的冒号:后边都要加一个空格，否则执行hexo命令会报错 5.部署到Github上12hexo generatehexo deploy 如过之前未关联过Github，执行hexo deploy的时候会提示你输入用户名密码，执行成功后，浏览器中敲打地址http://yourname.github.io， yourname是你自己的Github用户名。 6.使用Markdown书写文章并发布 Markdown是一种简化版的文字标记方式，被设计用来作为一种网络内容的写作用语言。你的yourname.github.io站点上的文章，就需要用这种语言。 Terminal里cd到&lt;folder&gt;下执行： 1hexo new &quot;filename&quot; 名为filename.md的文件会建在目录&lt;forder&gt;/soruce/_posts下，当然你也可以直接用编辑器在此文件夹下直接新建文件，比如Atom。 Terminal里执行： 12hexo ghexo d 以后你想发表博客文章的时候，无非就是在_posts目录中创建新的 .md 文件，而后 hexo generate，之后再 hexo deploy. Markdown语法很少，官网的教程通俗易懂，这里就不贴出来了，请直接进入官网学习Markdown ，尤其是Github Flavored Markdown。 至此网站初步搭建成功，但是正如你所看到的，网站很简约，使用也不是很方便，而且网站里什么都没有，下面我们对网站做些定制，以便让它好看些。当然，这些工作可以闲暇时间慢慢搞，慢慢来，耐心一点。 7.添加ssh key到Github7.1 生成ssh keyTerminal执行如下命令生成rsa key pair,注意“”中的地址换成你自己的，是注册Gtihup的邮箱地址。 $ ssh-keygen -t rsa -C “hzqiangmac@gmail.com” 执行完后会在路径~/.ssh下生成id_rsa和id_rsa.pub两个文件。 7.2 将ssh key添加到Github中打开~/.ssh/id_rsa.pub文件，里面的信息即为SSH key,将信息全部复制，粘贴到Github的Add SSH key页面。1Github--&gt;Settings--&gt;SSH and GPG keys--&gt;New SSH key Title标题随便起个名字，我的名字就是网站的名字zqhao.github.io,将上面复制的内容粘贴到key里，保存即可。 8.绑定个人域名此博客目前使用的域名是Github提供的二级域名，你也可以绑定为自己的个性域名。我是在阿里万网购买的域名，并且可直接在其网站上做域名解析。做过你会发现，很多事情并没有你想象的那么复杂，如果你没有尝试过这件事，鼓励你试着做一下。域名购买成功后，需要实名认证，国家要求必须要实名认证。 8.1添加CNAME文件在博客根目录下&lt;forder&gt;/source文件夹下新建CNAME文件，注意没有后缀，在里面添加你购买的域名信息，保存。Terminal里cd到&lt;forder&gt;目录下执行如下命令，重新部署网站，以后每次发布网站都需要执行一遍该命令：12hexo ghexo d 如果需要清空本地缓存，执行hexo clean,这里使用的hexo g和hexo d是第5部两个命令的缩写形式。 8.2给Github项目添加在项目的Settings中，在Custom domain中添加自己的域名： 8.3域名解析登录万网，在你购买的域名后边点击：解析 –&gt; 添加解析123记录类型：CNAME主机记录：填写@或者不填写记录值：yourname.github.io. (不要忘记最后的`.`) 保存之后，可能需要等一段时间才能生效,浏览器中敲入你购买的域名,ok！结束。 9.安装主题themeHexo官网主题里有很多主题，去上面找到自己喜欢的theme。我在搭建这个博客的时候，网上找的是hexo-theme-next，安装步骤很简单，直接去官网上看吧，因为你还需要定制很多东西，所以尽情DIY吧！ 到目前为止，算是大功告成了，后面要把精力放在使用Markdown写作上面，多写写有用的东西放在上面，这样你的这个网站才是有价值的，如果没有什么好的编辑器，这里推荐Atom编辑器，别问我问什么推荐这个，用用你就知道了，最重要的是适合自己。]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Git与Github]]></title>
    <url>%2F2017%2F09%2F19%2FGit%E4%B8%8EGithub%2F</url>
    <content type="text"><![CDATA[大学的时候就听说过Github,知道很多程序员都在使用Github，更是有很多大神在上面，不能说使用Github的才是优秀的程序员，但是有一点可以明确的是，github是程序员世界的社交平台，大家用彼此的语言高效交流，这是一种生活方式，而想要成为某个领域的高手，最好的方式就是按照高手的方式去生活，在他们的聚集地生活。 一直以来都没怎么好好认真做过一件事，所以接下来的两年里，我想把所有自己未曾做过的，对自己成长有帮助的事情做一遍，为了找回那丢失已久的自信，也为了给自己一个交代。好了，言归正传。 1.基础概念什么是Git Git是一个免费开源的分布式版本控制系统，被设计用于快速和高效处理任何项目。Git很容易学习且有着闪电般的性能。 什么是Github Github是一个基于web的Git版本控制仓库和Internet托管服务，主要用于代码。它提供了Git所有的分布式版本控制和源代码管理（功能），并添加了自己的特性。它为每个项目提供了访问控制和一些协作特性，例如bug跟踪、特性请求、任务管理等。 2.基本用法了解了要学习的东西是什么后，那么下面就开始学习基本的用法： Git在官网上有一个特别好的入门教程，大家可以访问网站上学习，30分钟足够入门，这是要用一辈子的事情。值得花时间好好学习下：https://try.github.io/levels/1/challenges/1 。在此不再多说，英文介绍不难理解，需要的话借助辞典。下面只对一些基础概念做些解释： staged: 表示文件处于已暂存的可以提交的状态。 unstaged:表示文件的改变还未暂存，当前状态下不可以提交。 untracked: 文件不在Git的管理中，这通常代表此文件是一个新文件。 deleted: 文件在本地已经删除正等待从Git上删除。 Staging Area: 可以理解为存放文件的地方（提交给Git仓库之前）。 Commit: “commit”命令可以视作仓库的快照，通过这种方式我们可以查看曾经做过对文件的所有改变，不管是自己还是别人操作的，它就像一个时间线一样，记录了所有的改变。 git remote: 将本地仓库上传到远程仓库，真正实现互联网协作。 git stash: 隐藏你自己的更改，git stash apply应用你的更改，一般用于拉取别人push的代码的时候。 当然一次学习不可能立马就能记住这些命令，很可能第一次正确理解这些概念都很难，不过没关系，这并不影响我们继续向前，在以后不断的实践的过程中你会慢慢理解这些概念的。 Github官网上也有个入门的教程Hello world，好的工具都是功能强大、简单易学的，所以请继续实践，这次15钟左右。。https://guides.github.com/activities/hello-world/。 同样下面只介绍概念： 学习一样知识或技能，首先就要掌握常用的概念，刚开始看不懂没关系，随着学习的继续深入，反复回过头来看，不断思考直至理解。这就像看书一样，会随着往后看的过程中，慢慢开始理解前面不太明白的地方。 respository: 仓库通常用于组织一个工程，可以包含任何你需要的东西，你的想法、资源甚至可以在上面与其他人分享和讨论。 branch: 分支可以让你在同一时间拥有同一仓库的不同版本，每个respository都有一个默认分支master，一般作为主分支。在Github中，branch一般用来修复bug和做些。分支是Git的核心概念，整个Github流就是基于此实现。未来的工作，当完成这些工作后，就会将子分支合并到主分支里。 pull request: 拉请求是在Github上协作的核心，当你打开一个拉请求，你提交你的改变并要求其他人查看你提交的东西并将它们合并到他们的分支中。拉请求显示了来自两个分支的内容的差异和不同。 在这里简单介绍下在Github里想要贡献自己代码的流程，方便大家理解pull requet： 1.fork别人的仓库，相当于拷贝一份别人的代码，然后clone到本地分支2.做些bug修复或添加新功能，然后发起pull request给原仓库作者，让他看到你的修改3.原仓库作者review这些改变，如果是正确的，他就会将你的这些改变merge到他自己的分支中 至此，整个pull request的过程结束，这也是在Github上与其他人协作的核心流程。 3.其他 习得任何技能的最根本技巧就是马上开始像那些已经精通这个技能的人一样生活. 所以请经常使用Github，没事的时候也在上面逛逛，也许就有收获。]]></content>
      <categories>
        <category>Git</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[写在开始]]></title>
    <url>%2F2017%2F09%2F06%2F%E5%86%99%E5%9C%A8%E5%BC%80%E5%A7%8B%2F</url>
    <content type="text"><![CDATA[曾经想，有台电脑就开始好好写作，有双运动鞋就开始好好跑步……于是一天一天就这么拖着，因为没电脑没好的运动鞋，所以没开始行动。将假设的前提没实现，当做自己不行动的的理由。我想生活应该是，哪怕残缺，也应该即刻开始出发，一步步变成自己理想的样子。]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>初心</tag>
      </tags>
  </entry>
</search>
