<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[SpringMVC+Hibernate4事务不提交问题处理]]></title>
    <url>%2F2018%2F04%2F09%2FSpring%20%E4%BA%8B%E5%8A%A1%E7%AE%A1%E7%90%86%E9%97%AE%E9%A2%98%E5%A4%84%E7%90%86%2F</url>
    <content type="text"><![CDATA[前段时间在整理实习生培训材料，基于两个常用框架的演示实例。在搭建框架的过程中，遇到了事务不提交的问题。 在实际工作中，每个项目组都有自己常用的开发框架，再加上分工协作，当新项目来的时候，如果架构没有什么大的变动，多数时候都是从原有项目里直接拖出一个框架。前段时间因工作原因在整理实习生培训材料，基于SSH和SSM框架的实例演示，由于想要保持干净的框架结构，所以特地对框架梳理了一番，将公司自带的一些jar包、配置等全部清除掉。 清理完后，开始运行项目，运行正常，于是就默认框架搭建正常。然后着手开始编写演示实例，在运行实例代码过程中，发现了事务一直无法提交。一般这种情况肯定就是配置文件没配置好，所以立马就去检查Spring的配置，来回检查了好几遍也没有发现问题，和正常运行的项目也做了对比，仍然没发现问题。项目中一直使用的AOP自动注解，除了方法命名规范需要注意，防止扫描不到，需要注意的地方很少。于是想着先去掉AOP自动注解，使用扫描 @Transaction 的方式，即&lt;tx:annotation-driven transaction-manager=&quot;txManager&quot;/&gt;发现事务仍然不能正常提交。好吧😂，继续搜索资料。 下面是一般的的AOP事务注解配置：12345678910111213141516&lt;bean id="transactionManager" class="org.springframework.orm.hibernate4.HibernateTransactionManager"&gt; &lt;property name="sessionFactory" ref="sessionFactory" /&gt;&lt;/bean&gt;&lt;tx:advice id="txAdvice" transaction-manager="transactionManager"&gt; &lt;tx:attributes&gt; &lt;tx:method name="list*" read-only="true" /&gt; &lt;tx:method name="save*" propagation="REQUIRED" /&gt; ..... &lt;/tx:attributes&gt; &lt;/tx:advice&gt; &lt;aop:config proxy-target-class="true"&gt; &lt;aop:pointcut expression="execution(public * com.example.sshdemo.service..*.*(..))" id="tranPointcut" /&gt; &lt;aop:advisor advice-ref="txAdvice" pointcut-ref="tranPointcut" order="2" /&gt; &lt;/aop:config&gt; 因为同样的的配置放在SpringMVC+MyBatis3框架里能用，当时放在SpringMVC+Hibernate4上却不能用，一时间就没找到思路。在和同事的沟通中，了解到可能是父子容器导致的问题，于是朝这个方向去搜寻答案，最终发现就是父子容器重复扫描包导致的。 spring-context.xml文件里的扫描路径一般配置到主目录，例如：&lt;context:component-scan base-package=&quot;com.example.sshdemo&quot; /&gt;，其中sshdemo是项目的主目录。但是spring-mvc.xml里的扫描配置必须要指定到Controller所在的级别，在这里，因为Controller都是定义在com.example.sshdemo.web下的，所以使用如下配置：&lt;context:component-scan base-package=&quot;com.example.sshdemo.web&quot; /&gt;，这样配置后事务就可以正常提交了。 下面来具体解释下父子容器的问题：因为Spring框架中有两个应用上下文，ApplicationContext和WebApplicationContext，它们是父子容器，因而有可能会产生冲突。当Web应用启动时，ServletContextListener配合contextConfigLocation会先启动“业务层”的Spring容器，即父容器。然后加载SpringMVC的配置文件，这里指定的是spring-mvc.xml文件，启动Web层的Spring容器，即子容器。子容器在对Controller层进行扫描装配时如果也扫描了Service层的注解，即@Service注解的实例，那么就会致事务无法被正确的加载进来。因为事务管理器是配置在父容器中的，@Service实例本该由父容器进行加载，这样才能得以保证事务拥有增强处理。如果是Web层容器扫描了该注解，因为没能得到这些事务增强，因此没有没有事务处理能力。 PS: SpringMVC+MyBatis3没有发现上述问题，SpringMVC+Hibernate4发现了上述问题。]]></content>
      <categories>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>SpringMVC</tag>
        <tag>Hibernate4</tag>
        <tag>Transaction</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring3.X学习笔记6-SpringAOP增强与切面]]></title>
    <url>%2F2018%2F02%2F25%2FSpring3.X%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B06-SpringAOP%20%E5%A2%9E%E5%BC%BA%E4%B8%8E%E5%88%87%E9%9D%A2%2F</url>
    <content type="text"><![CDATA[上一篇文章介绍了SpringAOP的基础知识以及所依赖的底层Java技术，本篇来说下SpringAOP的增强类型以及切面类型。 SpringAop的增强类型AOP联盟为增强定义了org.aopaliance.aop.Advice接口，下图为增强接口继承关系图： 带《spring》标识的接口是Spring所定义的扩展增强接口；带《aopalliance》标识的接口则是AOP联盟定义的接口。按照增强在目标类方法的连接点位置，可以分为以下5类： 前置增强： org.springframework.aop.BeforeAdvice代表前置增强，因为Spring只支持方法级别的增强，所以MethodBeforeAdvice是目前可用的前置增强，表示在方法执行前实施增强，而BeforeAdvice是为了将来版本扩展需要而定义的； 后置增强： org.springframework.aop.AfterReturningAdvice代表后增强，表示在目标方法执行后实施增强； 环绕增强： org.springframework.intercept.MethodInterceptor代表环绕增强，表示在目标方法执行前后实施增强； 异常抛出增强： org.springframework.aop.ThrowsAdvice代表抛出异常增强，表示在目标方法抛出异常后实施增强； 引介增强： org.springframework.aop.IntroductionInterceptor代表引介增强，表示在目标类中添加一些新的方法和属性。 在了解了基础信息后，下面就来分别看下各种增强的用法。通过使用 “保证服务生使用礼貌用语的例子” 来说明各种增强的使用方式。 前置增强服务生接口12345678910111213141516package com.hhxs.bbt.advice;public interface Waiter &#123; /** * 欢迎顾客 * @param name */ void greetTo(String name); /** * 对顾客提供服务 * @param name */ void serveTo(String name);&#125; 现在，来看一个未参加过培训的服务生的服务情况：12345678910111213141516package com.hhxs.bbt.advice;import org.springframework.stereotype.Component;@Componentpublic class NaiveWaiter implements Waiter &#123; @Override public void greetTo(String name) &#123; System.out.println("greet to " + name + "..."); &#125; @Override public void serveTo(String name) &#123; System.out.println("serving " + name + "..."); &#125;&#125; NaiveWaiter只是简单的向顾客打招呼，直接提供服务。下面，我们使用前置增强对NaiveWaiter的服务进行规范，让他们在提供服务之前，必须先对顾客使用礼貌用语。12345678910111213141516package com.hhxs.bbt.advice;import java.lang.reflect.Method;import org.springframework.aop.MethodBeforeAdvice;import org.springframework.stereotype.Component;@Componentpublic class GreetingBeforeAdvice implements MethodBeforeAdvice &#123; // 在目标类方法调用前执行 @Override public void before(Method method, Object[] args, Object target) throws Throwable &#123; String clientName = (String)args[0]; System.out.println("How are you! Mr." + clientName + "."); &#125;&#125; 上述代码中，我们看到了MethodBeforeAdvice接口的唯一方法before(Method method, Object[] args, Object obj) throws Throwable，method为目标类的方法；args为目标类方法的入参；而obj为目标类实例。当该方法发生异常时，将阻止目标类方法的执行。 下面编写测试例子，看下具体的执行情况：123456789101112131415161718192021package com.hhxs.bbt.advice;import org.springframework.aop.BeforeAdvice;import org.springframework.aop.framework.ProxyFactory;public class TestBeforeAdvice &#123; public static void main(String[] args) &#123; Waiter waiter = new NaiveWaiter(); BeforeAdvice advice = new GreetingBeforeAdvice(); // Spring提供的代理工厂 ProxyFactory pf = new ProxyFactory(); // 设置代理目标 pf.setTarget(waiter); // 为代理目标添加增强 pf.addAdvice(advice); // 生成代理实例 Waiter proxy = (Waiter) pf.getProxy(); proxy.greetTo("张三"); proxy.serveTo("李四"); &#125;&#125; 运行上面的代码，控制台输出信息如下，我们可以看到，通过前置增强在方法前面引入了礼貌用语。1234How are you! Mr.张三.greet to 张三...How are you! Mr.李四.serving 李四... 解剖ProxyFactory在TestBeforeAdvice中，我们使用org.springframework.aop.framework.ProxyFactory代理工厂将GreetingBeforeAdvice的增强织入到目标类NaiveWaiter中。有没有发现，调用方式与上一节介绍的JDK代理和CgLib代理很相似？不错，ProxyFactory的内部就是使用了JDK代理或CGLib技术。下图为AopProxy类结构： 其中，Cglib2AopProxy使用CGLib代理技术创建代理，而JdkDynamicAopProxy使用JDK代理技术创建代理。如果通过ProxyFactory的setInterfaces(Class[] interfaces)指定针对接口进行代理，ProxyFactory就使用JdkDynamicAopProxy；如果针对类的代理，则使用Cglib2AopProxy。此外，还可以通过ProxyFactory的setOptimize(true)方法，让ProxyFactory启动优化代理方式，这样，针对接口的代理也会使用CglibAopProxy。需要注意的是，用户可以通过调用ProxyFactory的addAdvice(Advice)方法添加多个增强，增强的调用顺序和添加顺序一致。 在Spring中配置 虽然使用ProxyFactory比直接使用CGLib或JDK代理技术创建代理省事很多，但是正如大家预想的一样，还可以通过Sping配置的方式来声明代理。 12345678910111213141516171819202122// spring1.xml代码片段&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:context="http://www.springframework.org/schema/context" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-3.1.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-3.1.xsd"&gt; &lt;context:component-scan base-package="com.hhxs.bbt.advice" /&gt; &lt;bean id="waiter" class="org.springframework.aop.framework.ProxyFactoryBean"&gt; &lt;property name="interfaces" value="com.hhxs.bbt.advice.Waiter" /&gt; &lt;property name="target" ref="naiveWaiter" /&gt; &lt;property name="interceptorNames"&gt; &lt;list&gt; &lt;value&gt;greetingBeforeAdvice&lt;/value&gt; &lt;/list&gt; &lt;/property&gt; &lt;/bean&gt;&lt;/beans&gt; 12345678910111213package com.hhxs.bbt.advice;import org.springframework.context.ApplicationContext;import org.springframework.context.support.ClassPathXmlApplicationContext;public class BeforeAdviceClient &#123; public static void main(String[] args) &#123; ApplicationContext context = new ClassPathXmlApplicationContext("spring/advice/spring1.xml"); Waiter waiter = (Waiter) context.getBean("waiter"); waiter.greetTo("张三"); waiter.serveTo("李四"); &#125;&#125; 下面介绍下ProxyFactoryBean的几个常用的可配置属性： target： 代理的目标对象； proxyInterfaces： 代理所要实现的接口，可以是多个接口。该属性还有一个别名属性interfaces； interceptorNames： 需要植入目标对象的Bean列表，采用Bean的名称指定。这些Bean必须是实现；了org.aopalliance.intercept.MethodInterceptor或org.springframework.aop.Advisor的Bean，配置中的顺序对应调用的顺序； singleton： 返回的代理是否是单实例，默认为单实例； optimize： 当设置为true时，强制使用CGLib代理。对于单实例的代理，推荐使用CGLib，对于其他作用域的代理，最好使用JDK代理。原因是CGLib创建代理时速度慢，而创建出的代理对象运行效率高，而使用JDK代理的表现正好相反； proxyTargetClass： 是否对类进行代理，设置为true时，使用CGLib代理。 后置增强后置增强在目标类方法调用后执行，接着上面的例子，增加服务后用语。12345678import org.springframework.aop.AfterReturningAdvice;public class GreetingAfterAdvice implements AfterReturningAdvice &#123; @Override public void afterReturning(Object returnValue, Method method, Object[] args, Object target) throws Throwable &#123; System.out.println("Please enjoy yourself!"); &#125;&#125; 其中returnValue为目标实例方法返回的结果；method为目标类的方法；args为目标实例的方法的入参；而target为目标类实例。12345678910111213// spring2.xml代码片段...&lt;bean id="waiter" class="org.springframework.aop.framework.ProxyFactoryBean"&gt; &lt;property name="interfaces" value="com.hhxs.bbt.advice.Waiter" /&gt; &lt;property name="target" ref="naiveWaiter" /&gt; &lt;property name="interceptorNames"&gt; &lt;list&gt; &lt;value&gt;greetingBeforeAdvice&lt;/value&gt; &lt;value&gt;greetingAfterAdvice&lt;/value&gt; &lt;/list&gt; &lt;/property&gt; &lt;/bean&gt;... 123456789public class AfterAdviceClient &#123; public static void main(String[] args) &#123; ApplicationContext context = new ClassPathXmlApplicationContext("spring/advice/spring2.xml"); Waiter waiter = (Waiter) context.getBean("waiter"); waiter.greetTo("张三"); waiter.serveTo("李四"); &#125;&#125; 运行上面的代码，控制台输出信息如下：123456How are you! Mr.张三.greet to 张三...Please enjoy yourself!How are you! Mr.李四.serving 李四...Please enjoy yourself! 环绕增强环绕增强允许在目标类方法调用前后织入横切逻辑，综合实现了前置、后置增强两者的功能。下面我们使用环绕增强实现上面的功能。1234567891011121314151617import org.aopalliance.intercept.MethodInterceptor;import org.aopalliance.intercept.MethodInvocation;public class GreetingInterceptor implements MethodInterceptor &#123; @Override public Object invoke(MethodInvocation invocation) throws Throwable &#123; // 获取目标方法入参 Object[] args = invocation.getArguments(); String clientName = (String) args[0]; System.out.println("How are you! Mr." + clientName + "."); // 通过反射机制调用目标方法 Object obj = invocation.proceed(); System.out.println("Please enjoy yourself!"); return obj; &#125;&#125; Spring直接使用AOP联盟所定义的 MethodInterceptor 作为环绕增强接口。该接口唯一的接口方法invoke(MethodInvocation invocation) throws Throwable，其中 MethodInvocation 不但封装目标方法及入参数组，还封装了目标方法所在的实例对象。 123456789101112// spring3.xml代码片段... &lt;bean id="waiter" class="org.springframework.aop.framework.ProxyFactoryBean"&gt; &lt;property name="interfaces" value="com.hhxs.bbt.advice.Waiter" /&gt; &lt;property name="target" ref="naiveWaiter" /&gt; &lt;property name="interceptorNames"&gt; &lt;list&gt; &lt;value&gt;greetingInterceptor&lt;/value&gt; &lt;/list&gt; &lt;/property&gt; &lt;/bean&gt;... 123456789public class AroundAdviceClient &#123; public static void main(String[] args) &#123; ApplicationContext context = new ClassPathXmlApplicationContext("spring/advice/spring3.xml"); Waiter waiter = (Waiter) context.getBean("waiter"); waiter.greetTo("张三"); waiter.serveTo("李四"); &#125;&#125; 异常抛出增强异常抛出增强最合适的应用场景是事务管理，当参与事务的某个Dao发生异常时，事务管理器就必须回滚事务。 ThrowsAdvice异常抛出增强接口没有定义任何方法，它是一个 标识接口，在运行期Spring使用反射的机制自行判断，但必须采用以下签名形式定义异常抛出的增强方法：void afterThrowing([Method method, Object[] args, Object target], Throwable)，方法名必须为 afterThrowing，方法入参规定：前三个入参Method method, Object[] args, Object target要么都提供，要么都不提供，而最后一个入参是Throwable或其子类。 标识接口是没有任何方法和属性的接口，标识接口不对实现类有任何语义上的要求，仅仅表明它的实现类属于一个特定的类型。它非常类似Web2.0中TAG的概念，Java使用它标识某一类对象。主要有两个用途：第一，通过标识接口标识同一类型的类，这些类本身可能并没有具有相同的方法，如Advice接口；第二，通过标识接口使程序或JVM采取一些特殊处理，如java.io.Serializable，它告诉JVM对象可以被序列化。 引介增强 引介增强是一种比较特殊的增强类型，它不是在目标方法周围织入增强，而是为目标类创建新的方法和属性，所以引介增强的连接点是类级别的。 Spring定义了引介增强接口 IntroductionInterceptor，该接口没有定义任何的方法，Spring为该接口提供了 DelegatingIntroductionInterceptor实现类，一般情况下，我们通过扩展该实现类定义自己的引介增强类。下面通过对上一篇文章SpringAOP基础里的性能监视例子进行改造，实现业务类性能监视功能的激活和关闭。 123public interface Monitorable &#123; void setMonitorActive(boolean active);&#125; 12345678910111213141516171819202122232425import org.aopalliance.intercept.MethodInvocation;import org.springframework.aop.support.DelegatingIntroductionInterceptor;public class ControllablePerformanceMonitor extends DelegatingIntroductionInterceptor implements Monitorable &#123; private static final long serialVersionUID = 1L; private ThreadLocal&lt;Boolean&gt; monitorStatusMap = new ThreadLocal&lt;Boolean&gt;(); public Object invoke(MethodInvocation mi) throws Throwable &#123; Object obj = null; if(monitorStatusMap.get() != null &amp;&amp; monitorStatusMap.get()) &#123; PerformanceMonitor.begin(mi.getClass().getName() + "." + mi.getMethod().getName()); obj = super.invoke(mi); PerformanceMonitor.end(); &#125; else &#123; obj = super.invoke(mi); &#125; return obj; &#125; @Override public void setMonitorActive(boolean active) &#123; monitorStatusMap.set(active); &#125;&#125; 123456789101112131415// beans.xml代码片段&lt;?xml version="1.0" encoding="UTF-8" ?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:p="http://www.springframework.org/schema/p" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-3.1.xsd"&gt; &lt;bean id="pmonitor" class="com.hhxs.bbt.introduce.ControllablePerformanceMonitor" /&gt; &lt;bean id="forumServiceTarget" class="com.hhxs.bbt.introduce.ForumService" /&gt; &lt;bean id="forumService" class="org.springframework.aop.framework.ProxyFactoryBean" p:interfaces="com.iflytek.bbt.introduce.Monitorable" &lt;!-- 引介增强所实现的接口--&gt; p:target-ref="forumServiceTarget" p:interceptorNames="pmonitor" p:proxyTargetClass="true" /&gt; &lt;!-- 引介增强只能通过目标类创建子类的方式生成引介增强的代理 --&gt;&lt;/beans&gt; 1234567891011121314public class TestIntroduce &#123; public static void main(String[] args) &#123; ApplicationContext ctx = new ClassPathXmlApplicationContext("com/hhxs/bbt/introduce/beans.xml"); ForumService forumService = (ForumService) ctx.getBean("forumService"); forumService.removeForum(10); forumService.removeTopic(1024); Monitorable monitorable = (Monitorable) forumService; monitorable.setMonitorActive(true); forumService.removeForum(10); forumService.removeTopic(1024); &#125;&#125; SpringAop的切面类型通过前面的学习，我们知道增强只提供了连接点的方位信息：如织入到方法前面，后面等，而切点进一步描述了织入到哪些类的哪些方法上。 Spring通过org.springframework.aop.Pointcut接口描述切点，Pointcut 由 ClassFilter 和 MethodMatcher 构成，它通过 ClassFilter 定位到某些特定类上，通过 MethodMatcher 定位到某些特定方法上。 Spring使用org.springframework.aop.Advisor接口表示切面的概念，一个切面同时包含横切代码和连接点信息。切面可以分为三类：一般切面、切点切面和引介切面。 Advisor： 代表一般切面，它仅包含一个Advice。Advice代表的横切连接点是所有目标类的所有方法，因为这个横切面太宽泛，所以很少使用； PointcutAdvisor： 代表具有切点的切面，它包含Advice和Pointcut两个类，这样就可以通过类、方法名以及方位等信息灵活地定义切面的连接点，提供更具适用性的切面； IntroductionAdvisor： 代表引介切面，引介切面是对应引介增强的特殊的切面，它应用于类层面上，所以引介切点适用 ClassFilter 进行定义。 下面看下PointcutAdvisor的6个具体实现类： DefaultPointAdvisor： 最常用的切面类型，它可以通过任意Pointcut和Advice定义一个切面，唯一不支持的是引介的切面类型； NameMatchMethodPointcutAdvisor： 通过该类可以定义按方法名定义切点的切面； RegexpMethodPointcutAdvisor： 对于按正则表达式匹配方法名进行切点定义的切面，可以通过扩展该实现类进行操作；。RegexpMethodPointcutAdvisor 内部通过 JdkRegexpMethodPointcut 构造出正则表达式方法名切点； StaticMethodMatcherPointcutAdvisor： 静态方法匹配器切点定义的切面，默认匹配所有的目标类； AspectJExpressionPointcutAdvisor： 用于AspectJ切点表达式定义切点的切面，它是Spring 2.0新提供的类； AspectJPointcutAdvisor： 用于AspectJ语法定义切点的切面，它是Spring 2.0新提供的类。 下面我们通过实例来了解下具体用法： 静态普通方法名匹配切面12345678910111213141516171819@Componentpublic class Waiter &#123; public void greetTo(String name) &#123; System.out.println("waiter greet to " + name + "..."); &#125; public void serverTo(String name) &#123; System.out.println("waiter serving " + name + "..."); &#125;&#125;@Componentpublic class Seller &#123; public void greetTo(String name) &#123; System.out.println("seller greet to " + name + "..."); &#125;&#125; Seller拥有一个和Waiter相同名称的方法greetTo()。现在希望通过 StaticMethodMatcherPointcutAdvisor 定义一个切面，在Waiter#greetTo()方法调用前织入一个增强。1234567891011121314151617181920// 切面类代码public class GreetingAdvisor extends StaticMethodMatcherPointcutAdvisor &#123; private static final long serialVersionUID = 1L; // 切点方法匹配规则：方法名为greetTo public boolean matches(Method method, Class&lt;?&gt; targetClass) &#123; return "greetTo".equals(method.getName()); &#125; // 切点类匹配规则：为Waiter的类或子类 @Override public ClassFilter getClassFilter() &#123; return new ClassFilter() &#123; public boolean matches(Class&lt;?&gt; clazz) &#123; return Waiter.class.isAssignableFrom(clazz); &#125; &#125;; &#125;&#125; 因为 StaticMethodMatcherPointcutAdvisor 抽象类唯一需要定义的是 matches() 方法。默认情况下匹配所有类，我们可以通过覆盖 getClassFilter() 方法，让它仅匹配Waiter类及其子类。123456789101112// 增强类@Componentpublic class GreetingBeforeAdvice implements MethodBeforeAdvice &#123; @Override public void before(Method method, Object[] args, Object target) throws Throwable &#123; System.out.println(target.getClass().getName() + "." + method.getName()); String clientName = (String) args[0]; System.out.println("How are you! Mr. " + clientName + "."); &#125;&#125; 1234567891011121314// beans.xml 配置切面: 静态方法匹配切面...&lt;context:component-scan base-package="com.hhxs.bbt.advisor" /&gt;&lt;!-- 向切面注入一个前置增强 --&gt;&lt;bean id="greetingAdvisor" class="com.hhxs.bbt.advisor.GreetingAdvisor" p:advice-ref="greetingBeforeAdvice" /&gt;&lt;bean id="parent" class="org.springframework.aop.framework.ProxyFactoryBean" p:interceptorNames="greetingAdvisor" p:proxyTargetClass="true" /&gt;&lt;bean id="waiter_c" parent="parent" p:target-ref="waiter"/&gt;&lt;bean id="seller_c" parent="parent" p:target-ref="seller"/&gt;... StaticMethodMatcherPointcutAdvisor 除了advice属性外，还可以定义另外两个属性： classFilter： 类匹配过滤器，在GreetingAdvisor中，我们用编码的方式设定了classFilter； order： 切面织入时的顺序，该属性用于定义Orderd接口标识的顺序。1234567891011public class TestStaticMethodAdvisor &#123; public static void main(String[] args) &#123; ApplicationContext ctx = new ClassPathXmlApplicationContext("com/hhxs/bbt/advisor/beans.xml"); Waiter waiter = (Waiter) ctx.getBean("waiter_c"); Seller seller = (Seller) ctx.getBean("seller_c"); waiter.greetTo("John"); waiter.serverTo("John"); seller.greetTo("John"); &#125;&#125; 运行以上代码，输出一下信息：12345com.hhxs.bbt.advisor.Waiter.greetToHow are you! Mr. John.waiter greet to John...waiter serving John...seller greet to John... 静态正则表达式方法匹配切面 在 StaticMethodMatcherPointcutAdvisor 中，我们仅能通过方法名定义切点，这种描述方式不够灵活。假设目标类中有多个方法，且它们都满足一定的命名规范，若能使用正则表达式进行匹配描述就灵活的多了。RegexpMethodPointcutAdvisor 是正则表达式方法匹配的切面实现类，需要注意的是：匹配模式串匹配的是目标类方法的全限定名，即带类名的方法名。下面我们用这个实现类对上面的实例进行改写：123456789101112131415161718192021...&lt;context:component-scan base-package="com.hhxs.bbt.advisor" /&gt; &lt;!-- 向切面注入一个前置增强 --&gt; &lt;bean id="greetingAdvisor" class="org.springframework.aop.support.RegexpMethodPointcutAdvisor" p:advice-ref="greetingBeforeAdvice"&gt; &lt;property name="patterns"&gt; &lt;list&gt; &lt;value&gt;.*greet.*&lt;/value&gt; &lt;/list&gt; &lt;/property&gt; &lt;/bean&gt; &lt;!-- 通过父&lt;bean&gt;定义公共配置信息 --&gt; &lt;bean id="parent" class="org.springframework.aop.framework.ProxyFactoryBean" p:interceptorNames="greetingAdvisor" p:proxyTargetClass="true" /&gt; &lt;bean id="waiter_c" parent="parent" p:target-ref="waiter"/&gt; &lt;bean id="seller_c" parent="parent" p:target-ref="seller"/&gt;... 运行以上代码，输出一下信息：1234567com.hhxs.bbt.advisor.Waiter.greetToHow are you! Mr. John.waiter greet to John...waiter serving John...com.hhxs.bbt.advisor.Seller.greetToHow are you! Mr. John.seller greet to John... PS： 除了例子中所使用的 patterns 和 advice 两属性外，还有另外两个属性： pattern： 如果只有一个匹配模式串，可以使用该属性进行配置，patterns属性用于定义多个匹配模式串，这些匹配模式串之间是 “或的关系”； order： 切面在织入时对应的顺序。 动态切面在低版本中，Spring提供了用于创建动态切面的 DynamicMethodMatcherPointcutAdvisor 抽象类，因为该类在功能上和其他类有重叠，目前已过期。我们可以使用 DefaultPointcutAdvisor 和 DynamicMethodMatcherPointcut 来完成相同的功能。下面直接看例子：123456789101112131415161718192021222324252627282930313233@Componentpublic class GreetingDynamicPointcut extends DynamicMethodMatcherPointcut &#123; private static List&lt;String&gt; specialClientList = new ArrayList&lt;String&gt;(); static &#123; specialClientList.add("John"); specialClientList.add("Tom"); &#125; @Override public ClassFilter getClassFilter() &#123; return new ClassFilter() &#123; public boolean matches(Class&lt;?&gt; clazz) &#123; System.out.println("调用getClassFilter()对" + clazz.getName() + "做静态检查."); return Waiter.class.isAssignableFrom(clazz); &#125; &#125;; &#125; @Override public boolean matches(Method method, Class&lt;?&gt; targetClass) &#123; System.out.println("调用matches(method, targetClass)" + targetClass.getName() + "." + method.getName() + "做静态检查."); return "greetTo".equals(method.getName()); &#125; @Override public boolean matches(Method method, Class&lt;?&gt; targetClass, Object[] args) &#123; System.out.println("调用matches(method, targetClass)" + targetClass.getName() + "." + method.getName() + "做动态检查."); String clientName = (String) args[0]; return specialClientList.contains(clientName); &#125;&#125; GreetingDynamicPointcut 类既有静态切点检查的方法，也有用于动态切点检查的方法。由于动态切点检查会对性能造成很大的影响，应当尽量避免在运行时每次都对目标类的各个方法进行动态检查。Spring采用这样的机制：在创建代理时对目标类的每个连接点使用静态切点检查，如果仅通过静态切点检查就可以知道连接点是不匹配的，则在运行时就不再进行动态检查了；如果静态切点检查是匹配的，在运行时才进行动态切点检查。1234567891011121314// dynamic_beans.xml 代码片段... &lt;context:component-scan base-package="com.hhxs.bbt.advisor" /&gt; &lt;bean id="dynamicAdvisor" class="org.springframework.aop.support.DefaultPointcutAdvisor" p:pointcut-ref="greetingDynamicPointcut" p:advice-ref="greetingBeforeAdvice"&gt; &lt;/bean&gt; &lt;!-- 通过父&lt;bean&gt;定义公共配置信息 --&gt; &lt;bean id="waiter2" class="org.springframework.aop.framework.ProxyFactoryBean" p:interceptorNames="dynamicAdvisor" p:target-ref="waiter" p:proxyTargetClass="true" /&gt;... 1234567891011// 动态切面测试代码public class TestDynamicAdvisor &#123; public static void main(String[] args) &#123; ApplicationContext ctx = new ClassPathXmlApplicationContext("com/hhxs/bbt/advisor/dynamic_beans.xml"); Waiter waiter = (Waiter) ctx.getBean("waiter2"); waiter.serverTo("Peter"); waiter.greetTo("Peter"); waiter.serverTo("John"); waiter.greetTo("John"); &#125; 运行以上代码，在控制台输出一下信息：12345678910111213141516171819202122232425// Spring在创建代理织入切面时，对目标类中所有方法进行静态切点检查调用getClassFilter()对com.hhxs.bbt.advisor.Waiter做静态检查.调用matches(method, targetClass)com.hhxs.bbt.advisor.Waiter.serverTo做静态检查.调用getClassFilter()对com.hhxs.bbt.advisor.Waiter做静态检查.调用matches(method, targetClass)com.hhxs.bbt.advisor.Waiter.greetTo做静态检查.调用getClassFilter()对com.hhxs.bbt.advisor.Waiter做静态检查.调用matches(method, targetClass)com.hhxs.bbt.advisor.Waiter.toString做静态检查.调用getClassFilter()对com.hhxs.bbt.advisor.Waiter做静态检查.调用matches(method, targetClass)com.hhxs.bbt.advisor.Waiter.clone做静态检查.// 对应waiter.serverTo(“Peter”）: 第一次调用serverTo()方法时，执行静态调用getClassFilter()对com.hhxs.bbt.advisor.Waiter做静态检查.调用matches(method, targetClass)com.hhxs.bbt.advisor.Waiter.serverTo做静态检查.waiter serving Peter...// 对应waiter.greetTo(“Peter”) : 第一次调用greetTo()时，执行静态动态检查调用getClassFilter()对com.hhxs.bbt.advisor.Waiter做静态检查.调用matches(method, targetClass)com.hhxs.bbt.advisor.Waiter.greetTo做静态检查.调用matches(method, targetClass)com.hhxs.bbt.advisor.Waiter.greetTo做动态检查.waiter greet to Peter...// 对应waiter.serverTo("John") ：第二次调用serverTo()时，不在执行静态waiter serving John...// 对应waiter.greetTo("John") ：第二次调用greetTo()时，只执行动态检查调用matches(method, targetClass)com.hhxs.bbt.advisor.Waiter.greetTo做动态检查.com.hhxs.bbt.advisor.Waiter.greetToHow are you! Mr. John.waiter greet to John... 在定义切点时，切勿忘记同时覆盖getClassFilter()和matches(Method method， Class targetClass)方法，通过静态切点检查可以排除掉大部分方法。 最后要说明的是，在Spring中，不管是静态切面还是动态切面都是通过动态代理技术实现的。所谓静态切面是指在生成代理对象时，就确定了增强是否需要织入到目标类连接点上，而动态切面是指必须在运行期根据方法入参的值来判断增强是否织入到目标类连接点上。 流程切面Spring的流程切面由 DefaultPointcutAdvisor 和 ControlFlowPointcut 实现。流程切点代表由某个方法直接或间接发起调用的其他方法。来看下面的实例，我们通过一个WaiterDelegat类代理Waiter所有的方法：12345678910111213public class WaiterDelegate &#123; private Waiter waiter; public void service(String clientName) &#123; waiter.greetTo(clientName); waiter.serverTo(clientName); &#125; public void setWaiter(Waiter waiter) &#123; this.waiter = waiter; &#125;&#125; 假设我们需要实现所有由WaiterDelegate#service()方法发起调用的其他方法都织入GreetingBeforeAdvice增强，就必须使用流程切面来完成目标。12345678910111213141516171819// controlflow_beans.xml 代码片段... &lt;context:component-scan base-package="com.hhxs.bbt.advisor" /&gt; &lt;bean id="controlFlowPointcut" class="org.springframework.aop.support.ControlFlowPointcut"&gt; &lt;constructor-arg type="java.lang.Class" value="com.hhxs.bbt.advisor.WaiterDelegate"/&gt; &lt;constructor-arg type="java.lang.String" value="service"/&gt; &lt;/bean&gt; &lt;bean id="controlFlowAdvisor" class="org.springframework.aop.support.DefaultPointcutAdvisor" p:pointcut-ref="controlFlowPointcut" p:advice-ref="greetingBeforeAdvice"&gt; &lt;/bean&gt; &lt;!-- 通过父&lt;bean&gt;定义公共配置信息 --&gt; &lt;bean id="waiter3" class="org.springframework.aop.framework.ProxyFactoryBean" p:interceptorNames="controlFlowAdvisor" p:target-ref="waiter" p:proxyTargetClass="true" /&gt;... ControlFlowPointcut有两个构造函数，分别是ControlFlowPointcut(Class clazz)和ControlFlowPointcut(Class clazz, String methodName)。第一个构造函数指定一个类作为流程切点；第二个构造函数指定一个类和某一个方法作为流程切点。 在这里，我们指定WaiterDelegate#service()方法作为切点，表示所有通过该方法直接或间接发起的调用匹配切点。123456789101112public class TestControlFlowAdvisor &#123; public static void main(String[] args) &#123; ApplicationContext ctx = new ClassPathXmlApplicationContext("com/hhxs/bbt/advisor/controlflow_beans.xml"); Waiter waiter = (Waiter) ctx.getBean("waiter3"); WaiterDelegate wd = new WaiterDelegate(); wd.setWaiter(waiter); waiter.serverTo("John"); waiter.greetTo("John"); wd.service("John"); &#125;&#125; 12345678waiter serving John...waiter greet to John...com.hhxs.bbt.advisor.Waiter.greetToHow are you! Mr. John.waiter greet to John...com.hhxs.bbt.advisor.Waiter.serverToHow are you! Mr. John.waiter serving John... 对于流程切面来说，代理对象在每次调用目标类方法时，都需要判断方法调用堆栈中是否满足流程切点的要求。因此，和动态切面一样，流程切面对性能的影响也很大。 复合切点切面在前面的例子中，我们所定义的切面仅有一个切点，有时，一个切点可能难以描述目标连接点的信息。比如上面流程切点的例子中，假如我们希望由WaiterDelegate#service()发起调用且被调用的方法是Waiter#greetTo()时才织入增强，这个切点就是复合切点。Spring为我们提供了 ComposablePointCut，可以将多个切点以并集或交集的方式组合起来，提供起点之间复合运算功能。下面，我们通过 ComposablePointcut 创建一个流程切点和方法名切点的相交切点，代码如下：12345678910111213@Componentpublic class GreetingComposablePointcut &#123; public Pointcut getIntersectionPointcut() &#123; // 创建一个复合切点 ComposablePointcut cp = new ComposablePointcut(); // 创建一个流程切点 Pointcut pt1 = new ControlFlowPointcut(WaiterDelegate.class,"service"); // 创建一个方法名切点 NameMatchMethodPointcut pt2 = new NameMatchMethodPointcut(); pt2.addMethodName("greetTo"); return cp.intersection(pt1).intersection((Pointcut)pt2); &#125;&#125; 123456789101112// composable_beans.xml 代码片段...&lt;context:component-scan base-package="com.hhxs.bbt.advisor" /&gt;&lt;bean id="composableAdvisor" class="org.springframework.aop.support.DefaultPointcutAdvisor" p:pointcut="#&#123;greetingComposablePointcut.intersectionPointcut&#125;" p:advice-ref="greetingBeforeAdvice" /&gt;&lt;!-- 通过父&lt;bean&gt;定义公共配置信息 --&gt;&lt;bean id="waiter4" class="org.springframework.aop.framework.ProxyFactoryBean" p:interceptorNames="composableAdvisor" p:target-ref="waiter" p:proxyTargetClass="true" /&gt;... 1234567891011public class TestComposableAdvisor &#123; public static void main(String[] args) &#123; ApplicationContext ctx = new ClassPathXmlApplicationContext("com/hhxs/bbt/advisor/composable_beans.xml"); Waiter waiter = (Waiter) ctx.getBean("waiter4"); WaiterDelegate wd = new WaiterDelegate(); wd.setWaiter(waiter); waiter.serverTo("Peter"); waiter.greetTo("Peter"); wd.service("Peter"); &#125;&#125; 运行以上代码，在控制台输出一下信息：123456waiter serving Peter...waiter greet to Peter...com.hhxs.bbt.advisor.Waiter.greetToHow are you! Mr. Peter.waiter greet to Peter...waiter serving Peter... 引介切面引介切面是引介增强的封装器，通过引介切面，我们更容易为现有对象添加任何接口的实现。IntroductionInfo 描述了目标类需要实现的新接口。IntroductionAdvisor 有两个实现类，分别是 DefaultIntroductionAdvisor 和 DeclareParentsAdvisor，前者是引介切面最常用的实现类，而后者是Spring2.0新添的实现类，它用于实现使用AspectJ语言的DeclareParent注解表示的引介切面。DefulatIntroductionAdvisor拥有三个构造函数： DefaultIntroductionAdvisor(Advice advice)： 通过一个增强创建的引介切面，引介切面将为目标对象新增增强对象中所有接口的实现； DefaultIntroductionAdvisor(DynamicIntroductionAdvice advice, Class clazz)： 通过一个增强和一个指定的接口类创建引介切面，仅为目标对象新增clazz接口的实现； DefaultIntroductionAdvisor(Advice advice，IntroductionInfo introductionInfo)： 通过一个增强和一个IntroductionInfo创建一个引介切面，目标对象需要实现哪些接口，由introductionInfo对象的getInterfaces()表示。 下面，我们通过DefaultIntroductionAdvisor为 前面的引介增强示例 配置切面：12345678910// introduce_beans.xml 代码片段... &lt;bean id="pmonitor" class="com.hhxs.bbt.introduce.ControllablePerformanceMonitor" /&gt; &lt;bean id="forumServiceTarget" class="com.hhxs.bbt.introduce.ForumService" /&gt; &lt;bean id="forumService" class="org.springframework.aop.framework.ProxyFactoryBean" p:interfaces="com.hhxs.bbt.introduce.Monitorable" p:target-ref="forumServiceTarget" p:interceptorNames="pmonitor" p:proxyTargetClass="true" /&gt;... 12345678910111213public class TestIntroduceAdvisor &#123; public static void main(String[] args) &#123; ApplicationContext ctx = new ClassPathXmlApplicationContext("com/hhxs/bbt/advisor/introduce_beans.xml"); ForumService forumService = (ForumService) ctx.getBean("forumService"); forumService.removeForum(10); forumService.removeTopic(1024); Monitorable monitorable = (Monitorable) forumService; monitorable.setMonitorActive(true); forumService.removeForum(10); forumService.removeTopic(1024); &#125;&#125; 自动代理在前面的例子中，可以看出，每一个需要被代理的 Bean 都需要使用一个 ProxyFactoryBean 进行配置，为每一个目标类手工配置一个切面是比较繁琐的。幸运的是，Spring为我们提供了自动代理机制，让容器为我们自动生成代理。 Spring使用 BeanPostProcessor 来完成这项工作。基于 BeanPostProcessor 的自动代理创建器的实现类，将根据一些规则自动在容器实例化Bean时为匹配的Bean生成代理实例。这些代理创建器可以分为以下三类： 基于Bean配置名规则的自动代理创建器： 允许为一组特定配置名的Bean自动创建代理实例的代理创建器，实现类为 BeanNameAutoProxyCreator； 基于Advisor匹配机制的自动代理创建器： 它会对容器中所有的Advisor进行扫描，自动将这些切面应用到匹配的Bean中，实现类为 DefaultAdvisorAutoProxyCreator； 基于Bean中AspjectJ注解标签的自动代理创建器： 为包含AspectJ注解的Bean自动创建代理实例，它的实现类是 AnnotationAwareAspectJAutoProxyCreator，该类是Spring2.0的新增类。 BeanNameAutoProxyCreator在静态正则表达式方法匹配切面中，通过配置两个ProxyFactoryBean分别为waiter和seller的Bean创建代理对象。下面，我们通过BeanNameAutoProxyCreator来完成相同功能：12345678... &lt;context:component-scan base-package=&quot;com.hhxs.bbt.advisor&quot; /&gt; &lt;bean class=&quot;org.springframework.aop.framework.autoproxy.BeanNameAutoProxyCreator&quot; p:beanNames=&quot;*er&quot; p:interceptorNames=&quot;greetingBeforeAdvice&quot; p:optimize=&quot;true&quot; /&gt;... BeanNameAutoProxyCreator有一个beanNames属性，它允许用户指定一组需要自动代理Bean名称，Bean名称可以使用*通配符。当然使用通配符会带来一定风险，在上面的例子中，假设一个其他的Bean名称以“er”结尾，则自动代理创建器也会为该Bean创建代理。所以，保险的方式是直接使用beanid，如value=”waiter，seller”。1234567891011public class TestBeanNameAutoProxyCreator &#123; public static void main(String[] args) &#123; ApplicationContext ctx = new ClassPathXmlApplicationContext("com/hhxs/bbt/autoproxy/beans.xml"); Waiter waiter = (Waiter) ctx.getBean("waiter"); Seller seller = (Seller) ctx.getBean("seller"); waiter.greetTo("John"); waiter.serverTo("John"); seller.greetTo("John"); &#125;&#125; 运行以上代码，在控制台输出一下信息：123456789com.hhxs.bbt.advisor.Waiter.greetToHow are you! Mr. John.waiter greet to John...com.hhxs.bbt.advisor.Waiter.serverToHow are you! Mr. John.waiter serving John...com.hhxs.bbt.advisor.Seller.greetToHow are you! Mr. John.seller greet to John... DefaultAdvisorAutoProxyCreatorDefaultAdvisorAutoProxyCreator能够扫描容器中的Advisor，并将Advisor自动织入到匹配的目标Bean中，即为匹配的目标Bean自动创建代理。 在静态方法匹配切面中，我们通过ProxyFactoryBean为waiter配置了代理，在这里，我们引入DefaultAdvisorAutoProxyCreator为容器中所有带“greet”方法名的目标Bean自动创建代理：12345678// beans.xml代码片段...&lt;!--通过Advisor自动创建代理--&gt;&lt;bean id="regexpAdvisor" class="org.springframework.aop.support.RegexpMethodPointcutAdvisor" p:patterns=".*greet.*" p:advice-ref="greetingBeforeAdvice" /&gt;&lt;bean class="org.springframework.aop.framework.autoproxy.DefaultAdvisorAutoProxyCreator" /&gt;... 1234567891011public class TestBeanNameAutoProxyCreator &#123; public static void main(String[] args) &#123; ApplicationContext ctx = new ClassPathXmlApplicationContext("com/hhxs/bbt/autoproxy/beans.xml"); Waiter waiter = (Waiter) ctx.getBean("waiter"); Seller seller = (Seller) ctx.getBean("seller"); waiter.greetTo("John"); waiter.serverTo("John"); seller.greetTo("John"); &#125;&#125; 运行以上代码，在控制台输出一下信息：1234567com.hhxs.bbt.advisor.Waiter.greetToHow are you! Mr. John.waiter greet to John...waiter serving John...com.hhxs.bbt.advisor.Seller.greetToHow are you! Mr. John.seller greet to John...]]></content>
      <categories>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>AOP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Maven Profile和Spring Proflie]]></title>
    <url>%2F2017%2F12%2F22%2FMaven%20Profile%20%E5%92%8C%20Spring%20profile%2F</url>
    <content type="text"><![CDATA[一个优秀的构建系统必须足够灵活，它应该能让项目在不同的环境下都能成功地构建。Maven为了支持构建的灵活性，内置了三大特性，即属性、Profile和资源过滤。这里我们只介绍Profile的使用，以及和Spring Profile的整合。 Maven Profile典型的项目一般都会有开发环境、测试环境以及生产环境，在不同的环境中，项目的源码应该使用不同的方式进行构建，这就要求项目构建的时候需要识别所在环境并使用正确的配置。为了能让构建在各个环境下方便的移植，Maven引入了profile的概念，profile可以让我们定义一系列的配置信息，然后指定其激活条件。这样我们就可以定义多个profile，然后每个profile对应不同的激活条件和配置信息，从而达到不同环境使用不同配置信息的效果。 profile的种类根据具体需要，可以在以下位置声明profile: pom.xml： 很显然，pom.xml中声明的profile只对当前项目有效。 用户settings.xml： 用户目录下 .m2/settings.xml中的profile对本机上该用户所有的Maven项目有效。 全局settings.xml： Maven安装目录下conf/setting.xml中的profile对本机中上所有的Maven项目有效。 profiles.xml（Maven2）： 还可以在项目根目录下使用一个额外的profiles.xml文件来声明profile，不过该特性已经在Maven3中被移除。建议用户将这类profile移到settings.xml中。 使用最多的两种方式是用户settings.xml和pom.xml方式，下面简要说明下不同位置的profile可使用的元素种类： POM中的profile可使用的元素，1234567891011121314151617&lt;project&gt; &lt;repositories&gt;&lt;/repositories&gt; &lt;pluginRepositories&gt;&lt;/pluginRepositories&gt; &lt;distributionManagement&gt;&lt;/distributionManagement&gt; &lt;dependencies&gt;&lt;/dependencies&gt; &lt;dependencyManagement&gt;&lt;/dependencyManagement&gt; &lt;modules&gt;&lt;/modules&gt; &lt;properties&gt;&lt;/properties&gt; &lt;reporting&gt;&lt;/reporting&gt; &lt;build&gt; &lt;plugins&gt;&lt;/plugins&gt; &lt;defaultGoal&gt;&lt;/defaultGoal&gt; &lt;resources&gt;&lt;/resources&gt; &lt;testResources&gt;&lt;/testResources&gt; &lt;finalName&gt;&lt;/finalName&gt; &lt;/build&gt;&lt;/project&gt; POM外部的profile可使用元素，12345&lt;project&gt; &lt;repositories&gt;&lt;/repositories&gt; &lt;pluginRepositories&gt;&lt;/pluginRepositories&gt; &lt;properties&gt;&lt;/properties&gt;&lt;/project&gt; 激活方式 默认激活方式 123456789&lt;profiles&gt; &lt;profile&gt; &lt;id&gt;dev&lt;/id&gt; &lt;activation&gt; &lt;activeByDefault&gt;true&lt;/activeByDefault&gt; &lt;/activation&gt; ... &lt;/profile&gt;&lt;/profiles&gt; 命令行激活可以使用mvn命令行参数-P加上profile的id来激活profile，多个id之间以逗号分隔。$mvn clean install -Pdev settings文件显示激活如果希望某个profile一直处于激活状态，就可以配置settings.xml文件的activeProfiles元素。 1234567&lt;settings&gt; ... &lt;activeProfiles&gt; &lt;actvieProfile&gt;dev&lt;/activeProfile&gt; &lt;/activeProfiles&gt; ...&lt;/settings&gt; 系统属性激活用户可以配置当某系统属性存在的时候，自动激活profile。然后在命令行声明系统属性：$mvn clean install -Dtest，这种方式和第2种很像，而且多个profile可以使用同一个系统属性来激活。 12345678910&lt;profiles&gt; &lt;profile&gt; &lt;activation&gt; &lt;property&gt; &lt;name&gt;test&lt;/name&gt; &lt;/property&gt; &lt;/activation&gt; ... &lt;/profile&gt;&lt;/profiles&gt; 操作系统环境激活Profile可以自动根据操作系统环境激活。这里的family的值包括Windows、UNIX和Mac等，而其他几项name、arch、version，用户可以通过查看环境中的系统属性os.name、os.arch、os.version获得。 12345678910111213&lt;profiles&gt; &lt;proflie&gt; &lt;activation&gt; &lt;os&gt; &lt;name&gt;Windows XP&lt;/name&gt; &lt;family&gt;Windows&lt;/family&gt; &lt;arch&gt;x86&lt;/arch&gt; &lt;version&gt;5.1.2600&lt;/version&gt; &lt;/os&gt; ... &lt;/activation&gt; &lt;/profile&gt;&lt;/profiles&gt; 文件存在与否激活Maven能够根据项目中某个文件存在与否来决定是否激活profile. 1234567891011&lt;profiles&gt; &lt;profile&gt; &lt;activation&gt; &lt;file&gt; &lt;missing&gt;x.properties&lt;/missing&gt; &lt;exists&gt;y.properties&lt;/exists&gt; &lt;/file&gt; &lt;/activation&gt; ... &lt;/profile&gt;&lt;/profiles&gt; 示例 在开发的过程中，我们一般会正在src/main/resource目录下放置配置文件xxx.xml或者xxx.properties。下面以数据库的配置为例来说明profile的使用方式，假设配置文件中有如下数据库配置：1234database.jdbc.driverclass=com.mysql.jdbc.Driverdatabase.jdbc.connectionURL=jdbc:mysql://localhost:3306/testdatabase.jdbc.username=devdatabase.jdbc.passowrd=dev-pwd 如果只是在一个环境中使用就没有什么问题，但是当测试人员想要构建项目进行测试，或者部署上线到生产环境，往往这些环境的信息是不同的，这就需要修改这个配置文件了。将这些配置参数提取到profile中：1234database.jdbc.driverclass=$&#123;db.driver&#125;database.jdbc.connectionURL=$&#123;db.url&#125;database.jdbc.username=$&#123;db.username&#125;database.jdbc.passowrd=$&#123;db.password&#125; pom.xml文件中新增prfile：123456789101112131415161718192021&lt;profiles&gt; &lt;profile&gt; &lt;id&gt;dev&lt;/id&gt; &lt;properties&gt; &lt;db.driver&gt;com.mysql.jdbc.Driver&lt;/db.driver&gt; &lt;db.url&gt;jdbc:mysql://localhost:3306/test&lt;/db.url&gt; &lt;db.username&gt;dev&lt;/db.username&gt; &lt;db.password&gt;dev-pwd&lt;/db.password&gt; &lt;/properties&gt; &lt;/profile&gt; &lt;profile&gt; &lt;id&gt;deploy&lt;/id&gt; &lt;properties&gt; &lt;db.driver&gt;com.mysql.jdbc.Driver&lt;/db.driver&gt; &lt;db.url&gt;jdbc:mysql://localhost:3306/deploy&lt;/db.url&gt; &lt;db.username&gt;deploy&lt;/db.username&gt; &lt;db.password&gt;deploy-pwd&lt;/db.password&gt; &lt;/properties&gt; &lt;/profile&gt;&lt;/profiles&gt; 有了属性定义，配置文件中也有了这些属性。但是Maven属性默认只有在POM中才会被解析，放在src/main/resources/下并不会被解析。因此需要借助maven-resource-plugin插件来为资源目录开启过滤，这样Maven就能解析资源文件中的Maven属性了。12345678910&lt;resources&gt; &lt;resource&gt; &lt;directory&gt;$&#123;project.basedir&#125;/src/main/resources&lt;/directory&gt; &lt;filtering&gt;true&lt;/filtering&gt; &lt;/resource&gt; &lt;resource&gt; &lt;directory&gt;$&#123;project.basedir&#125;/src/test/resources&lt;/directory&gt; &lt;filtering&gt;true&lt;/filtering&gt; &lt;/resource&gt;&lt;/resources&gt; Maven允许用户声明多个资源目录，并且为每个资源目录提供不同的过滤配置。最后，只需要在命令行激活profile，Maven就能够在构建项目的的时候使用profile中属性值替换数据库配置文件中的属性引用。运行命令行如下：$mvn clean install -Pdev Spring ProfileSpring profile是Spring 3.1引入的概念，通过定义profile来将若干不同的bean定义组织起来，从而实现不同环境自动激活不同的profile来切换配置参数的功能。 在实际项目的开发过程中，开发环境一般使用项目中自带文件，而在部署生产环境的时候使用指定目录下的配置文件，下面就以配置文件切换为例来说明profile的使用方法： 在applicationContext.xml里定义profile12345678910&lt;!-- dev环境 --&gt;&lt;beans profile="dev"&gt; &lt;context:property-placeholder ignore-resource-not-found="true" location="classpath:config/xxxx.properties" /&gt; ....&lt;/beans&gt;&lt;!-- deploy环境 --&gt;&lt;beans profile="deploy"&gt; &lt;context:property-placeholder ignore-resource-not-found="true" location="file:D:\xx\xxx\xxxx.properties"/&gt; ....&lt;/beans&gt; 或者：123456789101112131415161718192021 &lt;context:property-placeholder system-properties-mode="OVERRIDE" file-encoding="UTF-8" properties-ref="configProperties" /&gt; &lt;beans profile="dev"&gt; &lt;bean id="configProperties" class="org.springframework.beans.factory.config.PropertiesFactoryBean"&gt; &lt;property name="locations"&gt; &lt;list&gt; &lt;value&gt;classpath:config/xxxx.properties&lt;/value&gt; &lt;/list&gt; &lt;/property&gt; &lt;/bean&gt;&lt;/beans&gt;&lt;beans profile="deploy"&gt; &lt;bean id="configProperties" class="org.springframework.beans.factory.config.PropertiesFactoryBean"&gt; &lt;property name="locations"&gt; &lt;list&gt; &lt;value&gt;file:D:\xx\xxx\xxxx.properties&lt;/value&gt; &lt;/list&gt; &lt;/property&gt; &lt;/bean&gt;&lt;/beans&gt; 在web.xml定义默认profile默认profile是指在没有任何profile被激活的情况下，默认profile内定义的内容将被使用。1234 &lt;context-param&gt; &lt;param-name&gt;spring.profiles.default&lt;/param-name&gt; &lt;param-value&gt;dev&lt;/param-value&gt;&lt;/context-param&gt; 激活profilespring为我们提供了大量的激活profile的方法，可以通过代码来激活，也可以通过系统环境变量、JVM参数、servlet上下文参数来定义spring.profiles.active参数激活profile，这里我们通过定义servlet上下文参数参数实现。1234&lt;context-param&gt; &lt;param-name&gt;spring.profiles.active&lt;/param-name&gt; &lt;param-value&gt;$&#123;profiles.activation&#125;&lt;/param-value&gt;&lt;/context-param&gt; 其中，${profiles.activation}需要在实际运行项目的时候指定环境变量，这样既可以做到不同的环境下切换不同的配置文件，也可以直接设置具体值，这样可以省去2.4节的环境属性设置。 运行项目这里以jetty服务器做介绍，如果使用maven内置jetty插件启动，我们需要在pom中定义环境属性，如下图：如果是使用eclipse jetty插件启动，我们需要在服务器配置中增加环境变量，如下图： Maven整合Spring profile实际项目中我们大多以Maven来管理项目，所以这一部分来介绍如何在Maven中整合Spring profile。1.3节的示例已经介绍了在maven的pom文件中如何增加profile，并且指定了默认的激活profile，现在我们将其改为1234567891011121314151617&lt;profiles&gt; &lt;profile&gt; &lt;id&gt;dev&lt;/id&gt; &lt;activation&gt; &lt;activeByDefault&gt;true&lt;/activeByDefault&gt; &lt;/activation&gt; &lt;properties&gt; &lt;profiles.activation&gt;dev&lt;/profiles.activation&gt; &lt;/properties&gt; &lt;/profile&gt; &lt;profile&gt; &lt;id&gt;deploy&lt;/id&gt; &lt;properties&gt; &lt;profiles.activation&gt;deploy&lt;/profiles.activation&gt; &lt;/properties&gt; &lt;/profile&gt;&lt;/profiles&gt; 注意这里的&lt;profiles.actviation&gt;属性名称要和2.3 激活profile里配置的属性值${profiles.activation}对应，用于在打包的时候指定激活的profile 配置Maven插件，进行资源过滤1234567891011121314151617181920&lt;plugin&gt; &lt;artifactId&gt;maven-war-plugin&lt;/artifactId&gt; &lt;version&gt;2.0.2&lt;/version&gt; &lt;configuration&gt; &lt;warName&gt;$&#123;profiles.activation&#125;&lt;/warName&gt; &lt;!-- 激活spring profile --&gt; &lt;webResources&gt; &lt;resource&gt; &lt;filtering&gt;true&lt;/filtering&gt; &lt;directory&gt;$&#123;basedir&#125;/src/main/webapp&lt;/directory&gt; &lt;includes&gt; &lt;include&gt;**/web.xml&lt;/include&gt; &lt;/includes&gt; &lt;/resource&gt; &lt;/webResources&gt; &lt;warSourceDirectory&gt;$&#123;basedir&#125;/src/main/webapp&lt;/warSourceDirectory&gt; &lt;webXml&gt;$&#123;basedir&#125;/src/main/webapp/WEB-INF/web.xml&lt;/webXml&gt; &lt;warName&gt;实际打包名称或者用$&#123;profiles.activation&#125;替代，否则会找不到war包&lt;/warName&gt; &lt;/configuration&gt;&lt;/plugin&gt; 这一部很关键： 配置的目的是为了打包的时候，替换web.xml中配置的servlet上下文参数值${profiles.activation}，如果不配置，会发现打包后的web.xml中${profiles.activation}并没有被替换。 打包打包到部署环境$mvn clean install -Pdeploy 打包到体验环境$mvn clean install -Pdev 参考书籍： Maven实战 许晓斌著 spring proflie参考网上资料以及实际使用]]></content>
      <categories>
        <category>Maven</category>
      </categories>
      <tags>
        <tag>maven</tag>
        <tag>profile</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[列表排序思路]]></title>
    <url>%2F2017%2F12%2F20%2F%E5%88%97%E8%A1%A8%E6%8E%92%E5%BA%8F%E6%80%9D%E8%B7%AF%2F</url>
    <content type="text"><![CDATA[在项目里碰到一个需求，关于列表排序的，刚开始思路一直在基础的列表排序算法上，想了半天也没想出来怎么处理这种情况，越想越复杂。在网上查询资料的时候，意识到可以利用数据库本身去做排序更新，感觉思路比较新颖，因此在这里做个记录。 需求： 一个位置列表，初始的时候记录是没有排序序号的，用户可以随意设置每条记录的排序序号，设置完后，后台要更新数据，并完成其余数据的更新，并且最终的数据一定要是按顺序排列的，中间不能有间隔值。例如：原本 a:1、b:2、c:3、d:4 ，3的位置要更新为8，那么最终的排序排序应该是：a:1、b:2、d:3、c:4。 思路： 三个变量：原本的位置m，要修改的位置n，当前排序最大值max。1234567891011121314151617// 以下为伪代码if(n &gt; max + 1) &#123; n = max+1;&#125;if(是新增数据）&#123; if max&gt;=n &#123; update table set sort=sort+1 where sort&gt;=n and sort&lt;=max &#125;&#125; else if(修改数据) &#123; if m&gt;n &#123; update table set sort=sort+1 where sort&gt;=n and sort&lt;m &#125; else if m&lt;n &#123; update table set sort=sort-1 where sort&gt;m and sort&lt;=n &#125;&#125;update table set num = n where id = 业务数据ID]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>列表排序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring3.X学习笔记5-SpringAOP基础]]></title>
    <url>%2F2017%2F11%2F22%2FSpring3.X%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B05-SpringAOP%E5%9F%BA%E7%A1%80%2F</url>
    <content type="text"><![CDATA[Spring AOP是AOP技术在Spring中的具体实现，Spring AOP构建于IoC之上，和IoC一同构成了Spring的两大核心。 AOP概述AOP（Aspect Oriented Programming），即面向切面编程，可以说是OOP（Object Oriented Programming，面向对象编程）的补充和完善。OOP引入封装、继承、多态等概念来建立一种对象层次结构，用于模拟公共行为的一个集合。不过OOP允许开发者定义纵向的关系，但并不适合定义横向的关系，例如日志功能。日志代码往往横向地散布在所有对象层次中，而与它对应的对象的核心功能毫无关系。对于其它类型的代码，如安全性、异常处理和透明的持续性也都是如此，这种散布在各处的无关的代码被称为横切（cross cutting），在OOP设计中，它导致了大量代码的重复，而不利于各个模块的重用。 AOP技术恰恰相反，它利用一种称为”横切”的技术，剖解开封装的对象内部，并将那些影响了多个类的公共行为封装到一个可重用模块，并将其命名为”Aspect”，即切面。所谓”切面”，简单说就是那些与业务无关，却为业务模块所共同调用的逻辑或责任封装起来，便于减少系统的重复代码，降低模块之间的耦合度，并有利于未来的可操作性和可维护性。使用”横切”技术，AOP把软件系统分为两个部分：核心关注点和横切关注点。业务处理的主要流程是核心关注点，与之关系不大的部分是横切关注点。横切关注点的一个特点是，他们经常发生在核心关注点的多处，而各处基本相似，比如权限认证、日志、事物。AOP的作用在于分离系统中的各种关注点，将核心关注点和横切关注点分离开来。 AOP基础概念学习一个新事物首先就要了解其基本概念和关键术语，为了更好的理解AOP思想，下面先来看下有关AOP的重要概念： 连接点（Joinpoint）：被拦截到的点，因为Spring只支持方法类型的连接点，所以在Spring中连接点指的就是被拦截到的方法，实际上连接点还可以是字段或者构造器。连接点有两个信息确定：第一是方法表示的程序执行点；第二是相对点表示的方位。Spring使用切点对执行点进行定位，而方位在增强类型中定义。 切点（Pointcut）：对连接点进行拦截的定义，AOP通过“切点”定位特定连接点，一个切点可以匹配多个连接点。 增强（Advice）：指拦截到连接点之后要执行的代码，还包括方位信息，结合这个方位信息和上面的切点就可以定位到特定的连接点了。通知分为前置（BeforeAdvice）、后置（AfterRetuningAdvice）、异常（ThrowsAdvice）、最终、环绕通知五类。 目标对象（Target）：增强逻辑的织入目标类。 引介（Introduction）：在不修改代码的前提下，引介可以在运行期为类动态地添加一些方法或字段。 织入（Weaving）：织入是将增强添加到目标类具体连接点上的过程。根据不同的实现技术，AOP有三种织入的方式: 编译期织入，这要求使用特殊的Java编译器； 类装载期织入，这要求使用特殊的类装载器； 动态代理织入，在运行期为目标类添加增强生成子类的方式。 代理（Proxy）：一个类被AOP织入增强后，就生成了一个融合原类和增强逻辑的代理类。代理类可能是和原类具有相同接口的类，也可能就是原类的子类，所以我们可以采用调用原类相同的方式调用代理类。 切面（Aspect）：切面是横切关注点的抽象。它由切点和增强(引介)组成，它既包括了横切逻辑的定义，也包括连接点的定义，Spring AOP就是负责实施切面的框架，它将切面所定义的横切逻辑织入到切面所指定的连接点中。 提示： Spring采用动态代理织入，而Aspectj采用编译器织入和类装载器织入。 基础知识Spring AOP使用动态代理技术在运行期织入增强的代码，包括两种代理机制，一种是基于JDk的动态代理；另一种是基于CGLib的动态代理。下面先看一个未使用动态代理的例子：12345678910111213141516171819202122232425262728293031package com.hhxs.bbt.proxy;public class ForumServiceImpl implements ForumService &#123; @SuppressWarnings("static-access") @Override public void removeTopic(int topicId) &#123; // 性能监视开始 PerformanceMonitor.begin("com.hhxs.proxy.ForumServiceImpl.removeTopic"); System.out.println("模拟删除Topic记录:" + topicId); try &#123; Thread.currentThread().sleep(20); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; // 性能监视结束 PerformanceMonitor.end(); &#125; @SuppressWarnings("static-access") @Override public void removeForum(int forumId) &#123; PerformanceMonitor.begin("com.hhxs.proxy.ForumServiceImpl.removeForum"); System.out.println("模拟删除Forum记录:" + forumId); try &#123; Thread.currentThread().sleep(40); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; PerformanceMonitor.end(); &#125;&#125; 1234567891011121314151617181920package com.hhxs.bbt.proxy;public class PerformanceMonitor &#123; // 通过一个ThreadLocal保存调用线程相关的性能监视信息 private static ThreadLocal&lt;MethodPerformance&gt; performanceRecord = new ThreadLocal&lt;MethodPerformance&gt;(); // 启动对某一目标方法的性能监视 public static void begin(String method) &#123; System.out.println("begin monitor..."); MethodPerformance mp = new MethodPerformance(method); performanceRecord.set(mp); &#125; public static void end() &#123; System.out.println("end monitor..."); MethodPerformance mp = performanceRecord.get(); mp.printPerformance(); &#125;&#125; 123456789101112131415161718package com.hhxs.bbt.proxy;public class MethodPerformance &#123; private long begin; private long end; private String serviceMethod; public MethodPerformance(String serviceMethod) &#123; this.serviceMethod = serviceMethod; this.begin = System.currentTimeMillis(); &#125; public void printPerformance() &#123; end = System.currentTimeMillis(); long elapse = end - begin; System.out.println(serviceMethod + "花费" + elapse + "毫秒。"); &#125;&#125; 1234567891011package com.iflytek.bbt.proxy;import com.hhxs.bbt.proxy.ForumService;import com.hhxs.bbt.proxy.ForumServiceImpl;public class TestForumService &#123; public static void main(String[] args) &#123; ForumService forumService = new ForumServiceImpl(); forumService.removeForum(10); forumService.removeTopic(1012); &#125;&#125; 运行结果如下：12345678begin monitor...模拟删除Forum记录:10end monitor...com.hhxs.proxy.ForumServiceImpl.removeForum花费46毫秒。begin monitor...模拟删除Topic记录:1012end monitor...com.hhxs.proxy.ForumServiceImpl.removeTopic花费21毫秒。 正如上述代码所示，当某个方法需要进行性能监视，就必须调整方法代码，在方法前后分别添加上开启性能监视和结束性能监视的代码。我们希望通过代理的方式，将业务类方法中开启和结束性能监视的这些横切代码从业务类中完全剥离出来。并通过JDK动态代理技术或CGLib动态代理技术将横切代码织入到目标方法的相应位置。 JDK动态代理JDK的动态代理主要涉及到java.lang.reflect包中的两个类：Proxy和InvocationHandler。其中InvocationHandler，通过实现该接口定义横切逻辑。而Proxy利用InvocationHandler动态创建一个符合某一接口的实例，生成目标类的代理对象。 12345678910111213141516171819202122232425package com.hhxs.bbt.proxy;public class ForumServiceImpl implements ForumService &#123; @SuppressWarnings("static-access") @Override public void removeTopic(int topicId) &#123; System.out.println("模拟删除Topic记录:" + topicId); try &#123; Thread.currentThread().sleep(20); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; @SuppressWarnings("static-access") @Override public void removeForum(int forumId) &#123; System.out.println("模拟删除Forum记录:" + forumId); try &#123; Thread.currentThread().sleep(40); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125;&#125; 123456789101112131415161718package com.hhxs.bbt.proxy;import java.lang.reflect.InvocationHandler;import java.lang.reflect.Method;public class PerformanceHandler implements InvocationHandler &#123; private Object target; public PerformanceHandler(Object target) &#123; this.target = target; &#125; @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123; PerformanceMonitor.begin(target.getClass().getName()+"."+method.getName()); Object obj = method.invoke(target, args); PerformanceMonitor.end(); return obj; &#125;&#125; 首先，我们实现了InvocationHandler接口，该接口定义了一个invode(Object proxy,Method method,Object[] args)的方法。其中，method是被代理目标实例的某个具体方法，通过它可以发起目标实例方法的反射调用；args是传给被代理实例某一个方法的入参数组，在方法反射调用时使用。此外，我们在构造函数里通过target传入希望被代理的目标对象，在InvocationHandler接口方法invoke(Object proxy,Method method,Object[] args)里，将目标实例传给method.invoke()方法，调用目标实例的方法。 123456789101112131415161718192021package com.iflytek.bbt.proxy;import java.lang.reflect.Proxy;import com.hhxs.bbt.proxy.ForumService;import com.hhxs.bbt.proxy.ForumServiceImpl;import com.hhxs.bbt.proxy.PerformanceHandler;public class TestForumService &#123; public static void main(String[] args) &#123; // 希望被代理的目标业务类 ForumService target = new ForumServiceImpl(); // 将目标业务类和横切代码编织到一起 PerformanceHandler handler = new PerformanceHandler(target); // 根据编织了目标业务类逻辑和性能监视横切逻辑的InvocationHandler实例创建代理实例 ForumService proxy = (ForumService) Proxy.newProxyInstance(target.getClass().getClassLoader(), target.getClass().getInterfaces(), handler); proxy.removeForum(10); proxy.removeTopic(1012); &#125;&#125; 上面的代码完成业务类代码和横切代码的编织工作并生成了代理实例。运行以上代码，输出结果：12345678begin monitor...模拟删除Forum记录:10end monitor...com.hhxs.bbt.proxy.ForumServiceImpl.removeForum花费42毫秒。begin monitor...模拟删除Topic记录:1012end monitor...com.hhxs.bbt.proxy.ForumServiceImpl.removeTopic花费25毫秒。 CGLib动态代理通过上面的实例可以看出，使用JDK创建代理有一个限制，即它只能为接口创建代理实例。对于没有通过接口定义业务方法的类，JDK的代理技术就无法处理了，而CGLib采用非常底层的字节码技术，通过创建一个子类，并在子类中采用方法拦截所有父类方法的调用，并顺势织入横切逻辑。下面采用CGLib技术改造上面的例子：1234567891011121314151617181920212223package com.hhxs.bbt.proxy;import java.lang.reflect.Method;import net.sf.cglib.proxy.Enhancer;import net.sf.cglib.proxy.MethodInterceptor;import net.sf.cglib.proxy.MethodProxy;public class CglibProxy implements MethodInterceptor &#123; private Enhancer enhancer = new Enhancer(); public Object getProxy(Class&lt;?&gt; clazz) &#123; enhancer.setSuperclass(clazz); enhancer.setCallback(this); // 通过字节码技术动态创建子类实例 return enhancer.create(); &#125; @Override public Object intercept(Object obj, Method method, Object[] args, MethodProxy proxy) throws Throwable &#123; PerformanceMonitor.begin(obj.getClass().getName()+"."+method.getName()); Object result = proxy.invokeSuper(obj, args); PerformanceMonitor.end(); return result; &#125;&#125; 上述代码中，intercept(Object obj,Method method,Object[] args,MethodProxy proxy)是CGLib定义Interceptor接口的方法，它拦截所有目标类方法的调用，obj表示目标类的实例：method为目标类方法的反射对象；args为方法的动态入参；而proxy为代理类实例。12345678910111213package com.iflytek.bbt.proxy;import com.hhxs.bbt.proxy.CglibProxy;import com.hhxs.bbt.proxy.ForumServiceImpl;public class TestForumService &#123; public static void main(String[] args) &#123; CglibProxy proxy = new CglibProxy(); ForumServiceImpl forumService = (ForumServiceImpl) proxy.getProxy(ForumServiceImpl.class); forumService.removeForum(10); forumService.removeTopic(1024); &#125;&#125; 运行以上代码，输出结果：12345678begin monitor...模拟删除Forum记录:10end monitor...com.hhxs.bbt.proxy.ForumServiceImpl$$EnhancerByCGLIB$$5f4be940.removeForum花费62毫秒。begin monitor...模拟删除Topic记录:1024end monitor...com.hhxs.bbt.proxy.ForumServiceImpl$$EnhancerByCGLIB$$5f4be940.removeTopic花费24毫秒。 代理知识小结上述例子中，我们虽然通过PerformanceHandler或CglibProxy实现了性能监视横切逻辑的动态织入，但这种实现方式存在三个明显需要改进的地方： 目标类的所有方法都添加了性能监视横切逻辑，而有时，我们可能只是希望对业务类中的某些特定方法添加横切逻辑。 我们通过硬编码的方式指定的织入横切逻辑的切入点。 需要手工编写代理实例的创建过程，为不同类创建代理时，需要分别编写相应程序代码，无法做到通用。 以上三个问题，在AOP中占有重要的地位，Spring AOP的主要工作就是围绕以上三点展开：Spring AOP通过Pointcut（切点）指定在哪些类的哪些方法上织入横切逻辑，通过Advice（增强）描述横切逻辑和方法的具体织入点。此外，Spring通过Advisor（切面）将Pointcut和Advice两者组装起来。有了Advisor的信息，Spring就可以利用JDK或CGLib的动态代理技术采用统一的方式为目标Bean创建织入切面的代理对象了。值得一提的是，由于CGLib动态创建子类的方式生成代理对象，所以不能对目标类中的final，private等方法进行代理。]]></content>
      <categories>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>AOP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring3.X学习笔记4-Spring容器高级主题]]></title>
    <url>%2F2017%2F11%2F15%2FSpring3.X%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B04-Spring%E5%AE%B9%E5%99%A8%E9%AB%98%E7%BA%A7%E4%B8%BB%E9%A2%98%2F</url>
    <content type="text"><![CDATA[Spring容器是一部设计精妙的机器，其优异的外在表现是通过精细的内部设计实现的。本篇将对Spring容器进行解构，从内部探究Spring容器的体系结构和运行流程。 1、Spring容器技术内幕1.1 内部工作机制下图描述了Spring容器从加载配置文件到创建出一个完整Bean的作业流程以及参与的角色： ResourceLoader从存储介质中接收Spring配置文件，并使用Resource表示这个配置文件的资源； BeanDefinitionReader读取Resource所指向的配置文件资源，然后解析配置文件。配置文件中每一个&lt;bean&gt;解析成一个BeanDefinition对象，并保存到BeanDefinitionRegistery中； 容器扫描BeanDefinitionRegistery中的BeanDefinition，使用Java的反射机制自动识别出Bean工厂后处理器（实现BeanFactoryPostProcessor接口）的Bean，然后调用这些Bean工厂后处理器对BeanDefinitionRegistery中的BeanDefinition进行加工处理。主要完成以下两项工作： 对使用到占位符的&lt;bean&gt;元素标签进行解析，得到最终的配置值，这意味对一些半成品的BeanDefinition对象进行加工处理并得到成品的BeanDefinition对象； 对BeanDefinitionRegistery中的BeanDefinition进行扫描，通过Java反射机制找出所有属性编辑器的Bean(实现java.beans.PropertyEditor接口的Bean) ，并自动将它们注册到Spring容器的属性编辑器注册表中（PropertyEditorRegistry）； Spring容器从BeanDefinitionRegistery中取出加工后的BeanDefinition，并调用InstantiationStrategy着手进行Bean实例化的工作； 在实例化Bean时，Spring容器使用BeanWrapper对Bean进行封装，BeanWrapper提供了很多以Java反射机制操作Bean的方法，它将结合该Bean的BeanDefinition以及容器中属性编辑器，完成Bean属性的设置工作； 利用容器中注册的Bean后处理器（实现BeanPostProcessor接口的Bean）对已经完成属性设置工作的Bean进行后续加工，直接装配出一个准备就绪的Bean。 Spring组件按其所承担的角色可以划分为两类： 物料组件：Resource、BeanDefinition、PropertyEditor以及最终的Bean等，它们是加工流程中被加工、被消费的组件，就像流水线上被加工的物料； 加工设备组件：Resourceloader、BeanDefinitionReader、BeanFactoryPostProcessor、InstantiationStrategy以及BeanWrapper等组件像是流水线上不同环节的加工设备，对物料组件尽心国家公处理。 1.2 BeanDefinitionorg.springframework.beans.factory.config.BeanDefinition是配置文件&lt;bean&gt;元素标签的在容器中的内在表示。 RootBeanDefinition是最常用的实现类，它对应一般性的&lt;bean&gt;元素标签。如果有父子关系，父&lt;bean&gt;用RootBeanDefinition表示，子&lt;bean&gt;用ChildBeanDefinition表示，若没有父子关系，&lt;bean&gt;就使用RootBeanDefinition表示。 一般情况下，BeanDefinition只在容器启动时加载并解析，除非容器刷新或重启，这些信息不会发生变化。 1.3 InstantiationStrategyorg.springframework.beans.factory.support.InstantiationStrategy负责根据BeanDefinition对象创建一个Bean实例。之所以将实例化Bean的工作通过一个策略接口进行描述，是为了方便可以采用不同的实例化策略，以满足不同的应用需求。 SimpleInstantiationStrategy策略利用Bean实现类的默认构造函数、带参构造函数或工厂方法创建Bean的实例。CglibSubclassingInstantiationStrategy利用CGLib类库为Bean动态生成子类，在子类中生成方法注入逻辑，然后用这个子类创建Bean实例。 InstantiationStrategy仅负责实例化Bean的操作，它并不会参与Bean属性的设置工作。属性填充的工作将由下面的BeanWrapper来完成。 1.4 BeanWrapperorg.springframework.beans.BeanWrapper是Spring容器中重要的组件类。BeanWrapper相当于一个代理器，Spring通过BeanWrapper完成Bean属性的填充工作。 PropertyAccessor接口定义了各种访问Bean属性的方法，而PropertyEditorRegistry是属性编辑器的注册表。所以BeanWrapper实现类BeanWrapperImpl具有了三重身份： Bean包裹器 属性访问器 属性编辑器注册表 2、属性编辑器任何实现java.beans.PropertyEditor接口的类都是属性编辑器。属性编辑器的主要功能就是将外部的设置值，转换为JVM内部的对应类型，所以属性编辑器其实就是一个类型转换器。 2.1 JavaBean的编辑器JavaBean规范通过java.beans.PropertyEditor定义了设置JavaBean属性的方法，通过BeanInfo描述了JavaBean哪些属性是可定制的，此外还描述了可定制属性与PropertyEditor的对应关系。 BeanInfo与JavaBean之间的对应关系，通过两者之间规范的命名确立：对应JavaBean的BeanInfo采用如下的命名规范：&lt;Bean&gt;BeanInfo。如ChartBean对应的BeanInfo为ChartBeanBeanInfo。 JavaBean规范还提供了一个管理默认属性编辑器的管理器：PropertyEditorManager，该管理器内保存着一些常见类型的属性编辑器，如果某个JavaBean的常见类型属性没有通过BeanInfo显示指定属性编辑器，IDE将自动使用PropertyEditorManager中注册的对应默认属性编辑器。 PropertyEditor是属性编辑器的接口，它规定了将外部设置值转换为内部JavaBean属性值的转换接口方法。PropertyEditor主要的接口方法说明如下： Object getValues()：返回属性的当前值。基本类型被封装成对应的封装类实例； void setValue(Object newValue)：设置属性的值，基本类型以封装类传入； String getAsText()：将属性对象用一个字符串表示，以便外部的属性编辑器能以可视化方式显示。缺省返回null，表示该属性不能以字符串表示； void setAsText(String text)：用一个字符串去更新属性的内部值，这个字符串一般从外部属性编辑器传入； String[] getTags()：返回表示有效属性值的字符串数组，以便属性编辑器能以下拉框的方式显示出来。缺省返回null，表示该属性没有匹配的字符值有限集合。 String getJavaInitializationString()：为属性提供一个表示初始值的字符串，属性编辑器以此值作为属性的默认值。 BeanInfo主要描述了哪些属性可以编辑以及对应的属性编辑器，每一个属性对应一个属性描述器PropertyDescriptor。BeanInfo接口最重要的方法就是：PropertyDescriptor[] getPropertyDescriptors()，该方法返回JavaBean的属性描述器数组。 2.2 Spring默认属性编辑器Spring环境下的属性编辑器功能非常单一，仅需要将配置文件中字面值转换为属性类型的对象即可，并不需要提供UI界面，Spring为常见的属性类型提供了默认的属性编辑器。如下表所示： 类别 说明 基础数据类型 分为几个小类：1) 基本数据类型，如：boolean、byte、short、int等；2) 基本数据类型封装类：如：Long、Character、Integer等；3) 两个基本数据类型的数组，char[]和byte[]；4) 大数类，BigDecimal和BigInteger 集合类 为5种类型的集合类Collection、Set、SortedSet、List和SortedMap提供了编辑器 资源类 用于访问外部资源的8个常见类Class、Class[]、File、InputSteam、Locale、Properties、Resource[]和URL。 这些默认的属性编辑器解决常见属性类型的注册问题，如果用户的应用包括一些特殊类型的属性，且希望在配置文件中以字面值提供配置值，那么就需要编写自定义属性编辑器并注册到Spring容器中。（在Spring环境下自定义属性编辑器仅需要覆盖PropertyEditorSupport的setAsText()方法就可以了。）下面看一代码片段：我们现在希望在配置Boss时，不通过引用Bean的方式注入Boss的car属性，而希望直接通过字符串字面值提供配置。 12345678910111213141516171819202122232425262728293031323334353637// Car类public class Car &#123; private int maxSpeed; public String brand; pirvate double price; // 省略get/setter方法&#125;// Boss类public class Boss &#123; private String name; private Car car = new Car(); // 省略get/setter&#125;// Car自定义属性编辑器import java.beans.PropertyEditorSupportpublic class CustomCarEditor extends PropertyEditorSupport &#123; // 1.将字面值转换为属性类型对象 public void setAsText(String text) &#123; if(text == null || text.indexOf(",") == 1) &#123; throw new IllegalArgumentException("设置的字符串格式不正确"); &#125; String[] infos = text.split(","); Car car = new Car(); car.setBrand(infos[0]); car.setMaxSpeed(Integer.parseInt(infos[1])); car.setPrice(Double.parseDouble(infos[2])); // 2.调用父类的setValue()方法设置转换后的属性对象 setValue(car); &#125;&#125; 注册自定义属性编辑器：如果使用BeanFactory，用户需要手工调用registerCustomEditor(Class requiredType，PropertyEditor propertyEditor)方法注册自定义属性编辑器；如果使用ApplicationContext，则只需要在配置文件通过CustomEditorConfigurer注册即可。CustomEditorConfigurer实现BeanFactoryPostProcessor接口，因此是一个Bean工厂后处理器。 123456789101112131415161718&lt;!-- 1.配置自动注册属性编辑器的CustomEditorConfigurer --&gt;&lt;bean class="org.springframework.beans.factory.config.CustomEditorConfigurer"&gt; &lt;property name="customEditors"&gt; &lt;map&gt; &lt;!-- 2.1 属性编辑器对应的属性类型--&gt; &lt;entry key="com.hhxs.editor.Car"&gt; &lt;!-- 2.2 对应的属性编辑器Bean--&gt; &lt;bean class="com.hhxs.editor。CustomCarEditor"/&gt; &lt;/entry&gt; &lt;/map&gt; &lt;/property&gt;&lt;/bean&gt;&lt;bean&gt; &lt;property name="name" value=“John”/&gt; &lt;!-- 3.该属性将使用2处的属性编辑器完成属性填充操作 --&gt; &lt;property name="car" value="红旗CA72,200,20000.00"/&gt;&lt;/bean&gt; 提示： 按照JavaBeans的规范，JavaBeans的基础设施会在JavaBean相同类包下查找是否存在&lt;JavaBean&gt;Editor的类，如果存在，自动使用&lt;JavaBean&gt;Editor作为该JavaBean的PropertyEditor。Spring也支持这个规范，这样就无需显示在CustomEditorConfigurer中注册了。 3、使用外部属性文件在进行数据源以及文件服务器等资源配置时，我们可以直接在Spring配置文件中配置，但是这样会存在一个问题就是一旦相应的资源环境变了，我们就要去更改配置文件，这会增加我们的部署复杂度，增加维护工作量。还有一种更好的方式，是将这些经常变动的的配置信息独立到一个外部属性文件中，并在Spring配置文件中通过形如${user}、${password}等占位符引用属性文件中的属性项。 下面看一个配置数据源的例子： 123456789101112131415161718// jdbc.properties文件driverClassName=com.mysql.jdbc.Driver url=jdbc:mysql://localhost:3306/testuserName=rootpassword=1234// Spring配置文件代码片段&lt;!-- 1.引入jdbc.properties属性文件 --&gt;&lt;bean class="org.springframework.beans.factory.config.PropertyPlaceholderConfigurer" p:location="classpath:com/hhxs/placeholder/jdbc.properties" p:fileEncoding="utf-8"/&gt;&lt;!-- 2.通过属性名引用属性值 --&gt;&lt;bean id="dataSource" class=”org.apache。commons.dbcp.BasicDataSource” destroy-method="close" p:driverClassName="$&#123;driverClassName&#125;" p:url="$&#123;url&#125;" p:username="$&#123;userName&#125;" p:password="$&#123;password&#125;" /&gt; PropertyPlaceholderConfigurer其他属性 locations：如果只有一个属性文件，直接使用location属性指定就可以了，如果是多个属性文件，则可以通过locations属性进行设置，可以像配置List一样配置locations属性。 1234567&lt;property name="locations"&gt; &lt;list&gt; &lt;value&gt;jdbc1.properties/value&gt; &lt;value&gt;jdbc2.properties &lt;/value&gt; &lt;value&gt;jdbc3.properties&lt;/value&gt; &lt;/list&gt;&lt;/property&gt; fileEncoding： 属性文件的编码格式，Spring使用操作系统默认编码读取属性文件，如果属性文件采用了特殊编码，需要通过该属性显示指定。 order：如果配置文件中定义了多个PropertyPlaceHolderConfigurer，则通过该属性指定优先顺序。 placeholderPrefix：在上面的例子中，我们通过${属性名}引用属性文件中的属性项，其中”${“为默认的占位符前缀，可以根据需要改为其他的前缀符。 placeholderSuffix：占位符后缀，默认为”}”。 使用&lt;context:property-placeholder&gt;引用属性文件可以使用context命名空间定义属性文件，例如：1&lt;context:property-placeholder location="classpath:com/hhxs/bbt/placeholder/jdbc.properties"/&gt; 基于注解及基于Java类配置中引用属性基于注解配置的Bean可以通过@Value的注解为Bean的成员变量或方法入参自动注入容器已有的属性。如下所示：12345678910111213141516171819202122import org.springframework.beans.factory.annotation.Value;import org.springframework.stereotype.Component;@Componentpublic class MyDataSource &#123; @Value("$&#123;driverClassName&#125;") private String driverClassName; @Value("$&#123;url&#125;") private String url; @Value("$&#123;userName&#125;") private String userName; @Value("$&#123;password&#125;") private String password; public String toString() &#123; return ToStringBuilder.reflectionToString(this); &#125;&#125; 由于标注@Configuration的类本身相当于标注@Component，所以在标注@Configuration类中引用属性的方式和基于注解配置的引用方式是完全一样的。 5、容器事件Spring的ApplicationContext能够发布事件并且允许注册相应的事件监听器。Java中通过java.util.EventObject类和java.util.EventListener接口描述事件和监听器，某个组件或框架要建立自己的事件发布和监听机制，一般都通过扩展它们进行定义。在事件体系中，除了事件和监听器以外，还有另外三个重要的概念： 事件源：事件的生产者，任何一个EventObject都必须拥有一个事件源； 事件监听注册表：一个事件监听器注册到组件或框架中，其实就是保存在监听器注册表里，当组件和框架中的事件源产生事件时就会将事件通知这些位于注册表中的监听器； 事件广播器：负责把事件通知给事件监听器。 图片 事件体系角色 5.1 Spring事件类结构 事件类 ApplicationEvent的唯一构造函数是ApplicationEvent(Object source)，通过Source指定事件源，它的两个子类分别是： ApplicationContextEvent：容器事件，拥有4个子类分别表示容器启动、刷新、停止及关闭的时间； RequestHandleEvent：这是一个与Web应用相关的事件，当一个HTTP请求被处理后，产生该事件。只有在web.xml中定义了DispatcherServlet时才会产生该事件。 事件监听器接口 ApplicationListener接口之定义了一个方法：onApplicationEvent(E event)，该方法接受ApplicationEvent事件对象，在该方法中编写事件的响应处理逻辑。SmartApplicationListener接口是Spring3.0新增的，它定义了两个方法： boolean supportsEventType(Class&lt;? extends ApplicationEvent&gt; eventType)：指定监听器支持哪种类型的容器事件，即它只会对该类型的事件作出响应； boolean supportsSourceType(Class&lt;?&gt; sourceType)：该方法指定监听器仅对何种事件源对象作出响应。 事件广播器当发生容器事件时，容器主控程序将调用事件广播器将事件通知注册给注册表中的事件监听器。Spring为事件广播器定义了接口，并提供了实现类，如图： 5.2 解构Spring时间体系的具体实现Spring在ApplicationContext接口的抽象实现类AbstractApplicationContext中完成了事件体系的搭建。AbstractApplicationContext拥有一个applicationEventMulticaster成员变量，applicationEventMulticaster提供了容器监听器的注册表。AbstractApplicationContext在refresh()这个容器启动方法中通过以下三个步骤搭建了事件的基础设施，代码片段如下：12345678910...// 1 初始化应用上下文事件广播器initApplicationEventMulticaster();// 2 注册事件监听器registerListeners();// 3 完成刷新并发布容器刷新事件finishRefresh();... 1处，Spring初始化事件的广播器。用户可以在配置文件中为容器定义一个自定义的事件广播器，Spring会通过反射的机制将其注册成容器的事件广播器。如果没有找到配置的外部事件广播器，Spring自动使用SimpleApplicationEventMulticaster作为事件广播器。2处，Spring将根据反射机制，从BeanDefinitionRegistry中找出所有实现ApplicationListener的Bean，将它们注册为容器的事件监听器。3处，容器启动完成，调用事件发布接口向容器中所有的监听器发布事件。 下面看一个例子，一个模拟的邮件发送器。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889// MailSendEvent类package com.hhxs.bbt.event;import org.springframework.beans.BeansException;import org.springframework.context.ApplicationContext;import org.springframework.context.ApplicationContextAware;public class MailSender implements ApplicationContextAware &#123; private ApplicationContext ctx; @Override public void setApplicationContext(ApplicationContext ctx) throws BeansException &#123; this.ctx = ctx; &#125; public void sendMail(String to) &#123; System.out.println("MailSender：模拟发送邮件..."); MailSendEvent mse = new MailSendEvent(this.ctx, to); ctx.publishEvent(mse); &#125;&#125;// MailSendListener类package com.hhxs.bbt.event;import org.springframework.context.ApplicationListener;public class MailSendListener implements ApplicationListener&lt;MailSendEvent&gt; &#123; @Override public void onApplicationEvent(MailSendEvent event) &#123; MailSendEvent mse = (MailSendEvent) event; System.out.println("MailSendListener：向" + mse.getTo() + "发送完一封邮件"); &#125;&#125;// MailSender类package com.hhxs.bbt.event;import org.springframework.beans.BeansException;import org.springframework.context.ApplicationContext;import org.springframework.context.ApplicationContextAware;public class MailSender implements ApplicationContextAware &#123; private ApplicationContext ctx; @Override public void setApplicationContext(ApplicationContext ctx) throws BeansException &#123; this.ctx = ctx; &#125; public void sendMail(String to) &#123; System.out.println("MailSender：模拟发送邮件..."); MailSendEvent mse = new MailSendEvent(this.ctx, to); ctx.publishEvent(mse); &#125;&#125;// Spring配置文件&lt;?xml version="1.0" encoding="UTF-8" ?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-3.1.xsd"&gt; &lt;bean class="com.hhxs.bbt.event.MailSendListener"/&gt; &lt;bean id="mailSender" class="com.hhxs.bbt.event.MailSender"/&gt;&lt;/beans&gt;// 测试类ApplicatonEventTestpackage com.hhxs.bbt.event;import org.springframework.context.ApplicationContext;import org.springframework.context.support.ClassPathXmlApplicationContext;public class ApplicatonEventTest &#123; public static void main(String[] args) &#123; String resourceFile = "com/hhxs/bbt/event/beans.xml"; ApplicationContext ctx = new ClassPathXmlApplicationContext(resourceFile); MailSender mailSender = ctx.getBean(MailSender.class); mailSender.sendMail("event@mail.com"); System.out.println("done."); &#125;&#125; 运行结果如下：123MailSender：模拟发送邮件...MailSendListener：向event@mail.com发送完一封邮件done.]]></content>
      <categories>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring3.X学习笔记3-基于注解和基于Java类的配置]]></title>
    <url>%2F2017%2F11%2F07%2FSpring3.X%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B03-%E5%9F%BA%E4%BA%8E%E6%B3%A8%E8%A7%A3%E7%9A%84%E9%85%8D%E7%BD%AE%E5%92%8C%E5%9F%BA%E4%BA%8EJava%E7%B1%BB%E7%9A%84%E9%85%8D%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[上一篇文章里我们主要介绍了基于XML Schemal的配置方式。本篇文章里将介绍另外两种提供Bean定义的方式，基于注解和基于Java类的配置。 1、基于注解的配置不管是XML还是注解，他们都是表达Bean定义的载体，其实质都是为Spring容器提供Bean定义的信息，表现形式上是将XML定义的东西通过类注解进行描述。Spring从2.0开始引入基于注解的配置方式，在3.0时得到进一步的完善。下面是使用注解定义一个DAO的Bean:12345678package com.hhxs.bbt.dao;import org.springframework.stereotype.Component;// 1.通过Repository定义一个DAO的Bean@Component("userDao")public class UserDao &#123; ...&#125; 在上面1处，使用@Component注解在UserDao类声明处对类进行标注，它可以被Spring容器识别，Spring容器自动将POJO转换为容器管理的Bean。它和以下的XML配置是等效的：1&lt;Bean id="userDao" class="com.hhxs.bbt.dao.UserDao"&gt; 除了@Component以外，Spring提供了三个功能基本和@Component等效的注解，它们分别用于对DAO、Service及Web层的Controller进行注解，所以也称这些注解为Bean的衍型注解： @Repository：用于对DAO实现类进行标注； @Service：用于对Service实现类进行标注； @Controller：用于对Controller实现类进行标注。 在@Component之外提供这三个注解，是为了让注解类本身的用途更加清晰，此外Spring还赋予了它们一些特殊功能。 1.1 使用注解配置信息启动Spring容器Spring在2.5 后提供了一个context的命名空间，它提供了通过扫描类包以应用注解定义Bean的方式： 12345678910111213&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:context="http://www.springframework.org/schema/context" xsi:schemaLocation="http://www.springframework.org/schema/beans" http://www.springframework.org/schema/beans/spring-beans-3.1.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-3.1.xsd&gt; &lt;description&gt;Spring公共配置 &lt;/description&gt; &lt;!-- 1.扫描类包以应用注解定义的Bean --&gt; &lt;context:component-scan base-package="com.hhxs.bbt" /&gt;&lt;/beans&gt; 在上面1处通过context命名空间的compnent-scan的base-package属性指定一个需要扫描的基类包，Spring容器将会扫描这个基类包里的所有类，并从类的注解信息中获取Bean的定义信息。 如果仅希望扫描特定的类而非基包下的所有类，那么可以使用resource-pattern属性过滤特定的类，如下所示： 1&lt;context:component-scan base-package="com.hhxs.bbt" resource-pattern="dao/*.class"/&gt; 默认情况下resource-pattern属性的值为**/*.class，即基包里的所有类。这里我们设置为dao/*.class，则Spring仅会扫描基包里dao子包中的类。通过resource-pattern属性仅可按资源名称对基包中的类进行过滤，如果需要更详细的过滤，则需要用到&lt;contex:component-scan&gt;的过滤子元素： 1234&lt;context:component-scan base-package="com.hhxs.bbt"&gt; &lt;context:include-filter type="regex" expression="com.\hhxs.\bbt.*"/&gt; &lt;context:exclude-filter type="aspectj" expression="com.hhxs.bbt..*Controller+"/&gt;&lt;/context&gt; &lt;context:include-filter&gt;表示要包含的目标类 &lt;context:exclude-filter&gt;表示要排除在外的目标类 一个&lt;context:component-scan&gt;下可以包含若干个&lt;context:include-filter&gt;和&lt;context:exclude-filter&gt;元素。这两个过滤元素均支持多种类型的过滤表达式，如下表所示： 类别 示例 说明 annotation com.hhxs.bbt.XxxAnnotation 所有标注了XxxAnnotation的类。该类型采用目标类是否标注了某个注解进行过滤。 assignable com.hhxs.bbt.XxxService 所有继承或扩展XxxService的类。该类型采用目标类是否继承或扩展某个特定类进行过滤。 aspectj com.hhxs.bbt..*Service+ 所有类名以Service结束的类及继承或扩展它们的类。该类型采用AspectJ表达式进行过滤。 regex com.hhxs.bbt..* 所有com.hhxs.bbt类包下的类。该类型采用正则表达式根据目标类的类名进行过滤。 custom com.hhxs.bbt.XxxTypeFilter 采用XxxTypeFilter通过代码的方式根据过滤规则。该类必须实现org.springframework.core.type.TypeFilter接口 1.2 自动装配Beanspring使用@Autowired注解实现Bean的依赖注入。@Autowired默认按类型匹配的方式，在容器查找匹配Bean,当且仅有一个匹配的Bean时，Spring将其注入到@Autowired标注的变量中。 123456789101112131415package com.hhxs.bbt.service;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.stereotype.Service;@Servicepublic class LogonService &#123; @Autowired private LogDao logDao; @Autowired private UserDao userDao; ...&#125; 如果容器中没有一个和标注变量类型匹配的bean，Spring容器启动时将报NoSuchBeanDefinitionException异常。如果希望不抛出异常可以使用@Autowired(required=false)进行标注。默认情况下，@Autowired的required属性值为true。 如果容器中有一个以上匹配的Bean时，可以通过@Qualifier注解限定Bean的名称。 1234567891011121314151617package com.hhxs.bbt.service;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.beans.factory.annotation.Qualifier;import org.springframework.stereotype.Service;@Servicepublic class LogonService &#123; @Autowired private LogDao logDao; @Autowired @Qualifier("userDao") private UserDao userDao; ...&#125; 对集合类进行标注如果对类中集合类的变量和方法入参进行@Autowired标注，Spring会将容器中类型匹配的所有Bean都自动注入进来。这是一个很好的特性，所以在这里介绍下。 1234567891011121314151617package com.hhxs.bbt.service;import java.util.List;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.beans.factory.annotation.Qualifier;import org.springframework.stereotype.Service;@Servicepublic class MyComponent &#123; // Spring会将容器中所有类型为Plugin的Bean注入到这个变量中 @Autowired(required=false) private List&lt;Plugin&gt; plugins; public List&lt;Plugin&gt; getPlugins() &#123; return plugins; &#125;&#125; Spring如果发现变量是一个集合类，则它会将容器中匹配集合元素类型的所有Bean都注入进来。这里，Plugin为一个接口，它拥有两个实现类，分别是OnePlugin和TwoPlugin，这两个实现类都通过@Component标注为Bean，则Spring会将这两个Bean都注入到plugins中。 2、基于Java类的配置2.1 使用Java类提供Bean定义信息JavaConfig是Spring的一个子项目，它旨在通过Java类的方式提供Bean的定义信息。Spring3.0基于Java类配置的核心即取材于JavaConfig。 普通的POJO只要标注@Configuration注解，就可以为Spring容器提供Bean定义的信息了，每个标注了@Bean的类方法都相当于提供一个Bean的定义信息。 12345678910111213141516171819202122232425import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;// 1.将一个POJO标注定义为Bean的配置类@Configurationpublic class AppConf &#123; // 2.以下两个方法定义了两个Bean，并提供了Bean的实例化逻辑 @Bean public UserDao userDao() &#123; return new UserDao(); &#125; @Bean public LogDao logDao() &#123; return new LogDao() &#125; @Bean public LogonService logonService() &#123; LogonServcie logonService = new LogonService(); // 将上面2处定义的Bean注入到logonService的Bean logonService.setLogDao(logDao()); logonService.setUserDao(userDao()); return logonService; &#125;&#125; 1处在AppConf类的定义处标注了@Configuration注解，说明这个类可用于为Spring提供Bean信息。类的方法出可以标注@Bean注解，Bean的类型由方法返回值类型决定，名称默认和方法名相同，也可通过@Bean(name=”userDao”)显示指定Bean的名称。 上面的配置和以下XML配置等效： 1234&lt;bean id="userDao" class="com.hhxs.bbt.dao.UserDao" /&gt;&lt;bean id="logDao" class="com.hhxs.bbt.dao.LogDao" /&gt;&lt;bean id="userDao" class="com.hhxs.bbt.conf.LogonService" p:logDao-ref="userDao" p:userDao-ref="logDao" /&gt; 2.2 使用基于Java类的配置信息启动Spring容器2.2.1 直接通过@Configuration类启动Spring容器Spring提供了一个AnnotationConfigApplicationContext类，它能够直接通过标注@Configuration的Java类启动Spring容器。以下两种方式是等效的： 第一种： 123456789101112package com.hhxs.bbt.conf;import org.springframework.context.ApplicationContext;import org.springframework.context.annotation.AnnotationConfigApplicationContext;public class JavaConfigTest &#123; public static void main(String[] args) &#123; ApplicationContext ctx = new AnnotationConfigApplicationContext(AppConf.class); LogonService logonService = ctx.getBean(logonService.class); logonService.printHello(); &#125;&#125; 第二种：1234567891011121314151617package com.hhxs.bbt.conf;import org.springframework.context.ApplicationContext;import org.springframework.context.annotation.AnnotationConfigApplicationContext;public class JavaConfigTest &#123; public static void main(String[] args) &#123; AnnotationConfigApplicationContext ctx = new AnnotationConfigApplicationContext(); // 注册多个@Configuration配置类 ctx.register(DaoConfig.Class); ctx.register(ServiceConfig.class); // 刷新容器以应用这些注册的配置类 ctx.refresh(); LogonService logonService = ctx.getBean(logonService.class); logonService.printHello(); &#125;&#125; 可以通过代码一个一个注册配置类，也可以通过@Import将多个配置类组装到一个配置类中，这样仅需要注册这个组装好的配置类就可以启动容器了。1234567891011121314package com.hhxs.bbt.conf;import org.springframework.beans.factory.annotation.Configurable;import org.springframework.context.annotation.Import;@Configurable@Import(DaoConfig.class)public class ServiceConfig &#123; @Bean public LogonService logonService() &#123; LogonService logonService = new LogonService(); return logonService; &#125;&#125; 我们既可以在XML配置文件中引用@Configuration的配置，也可以通过Configuration配置类中引用XML配置信息。只要不同形式的Bean定义信息能够加载到Spring容器中，Spring就能足够“智能”的完成Bean之间的装配。 3、不同配置方式比较配置方式比较： – 基于XML配置 基于注解配置 基于Java类配置 Bean定义 &lt;bean class=&quot;com.hhxs.bbt.UserDao&quot;&gt; Bean实现类出通过标注 @Component、@Repository、@Service、@Controller 在标注了@Configuration的Java类中，通过在类方法上标注@Bean定义一个Bean。方法必须提供Bean的实例化逻辑。 Bean名称 通过的id或name属性定义 通过注解的value属性定义，如@Component(“userDao”)。默认名称为小写字母打头的类名（不带包名）：userDao 通过@Bean的name属性定义，如@Bean(“userDao”)，默认名称为方法名。 Bean注入 通过子元素或通过p命名空间的动态属性 通过在成员变量或方法入参出标注@Autowired，按类型匹配自动注入 可以通过在方法处通过@Autowired使方法入参绑定Bean，然后在方法中通过代码进行注入，还可以通过调用配置类的@Bean方法进行注入 Bean生命过程方法 通过的init-method和destory-method属性指定Bean实现类的方法名。最多只能指定一个初始化方法和一个销毁方法 通过在目标方法上标注@PostConstruct和@PreDestroy注解指定初始化或销毁方法，可以定义任意多个方法 通过@Bean的initmethod或destoryMethod指定一个初始化或销毁方法。 Bean作用范围 通过的scope属性指定 通过在类定义出标注@Scope指定 通过在Bean方法定义处标注@Scope指定 Bean延迟初始化 通过的lazy-init属性指定，默认为default，继承与的default-lazy-init设置，该值默认为false 通过在类定义处标注@Lazy指定，如@Lazy(true) 通过在Bean方法定义处标注@Lazy指定 使用场景建议： – 基于XML配置 基于注解配置 基于Java类配置 适合场景 1）Bean实现类来源于第三方类库 2）命名空间的配置 Bean实现类是当前项目开发的，可以直接在Java类中使用基于注解的配置 基于Java类配置的优势在于可以通过代码方式控制Bean初始化的整体逻辑。]]></content>
      <categories>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>Bean</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring3.X学习笔记2-Bean的基本配置]]></title>
    <url>%2F2017%2F11%2F07%2FSpring3.X%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B02-Bean%E7%9A%84%E5%9F%BA%E6%9C%AC%E9%85%8D%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[知易行难，由于之前很少写技术博客，对于写一篇“还算正式”的技术文章需要花费多少时间并不清楚。第一篇笔记整理了将近一周，这远远超出了我的预期。写完的时候，不免想起那些经常写博客的人一定花费了很多的心思在上面，因而心生佩服。很多事情都是这样，只有做过才会知道其中的不容易。 1、Spring配置概述1.1 Spring容器高层视图Spring容器根据各种形式的Bean配置信息在容器内部建立Bean定义注册表，然后根据注册表加载、实例化Bean，并建立Bean和Bean的依赖关系。Bean的配置信息是Bean的元数据信息，Bean的元数据信息在Spring容器中的内部对应物是由一个一个BeanDefinition形成的Bean注册表，Spring实现了Bean元数据信息内部表示和外部表示的解耦。如下图： 1.2 基于XML Schema的配置基于XML的配置，Spring2.0以后开始使用Schema格式，相比Spring1.0的DTD格式，Schema让不同类型的配置拥有了自己的命名空间，使配置文件更具扩展性。下面看一个简单的示例： Schema在文档根节点中通过xmlns对文档中的命名空间进行声明。在上面的代码中定义了3个命名空间： 默认命名空间：它没有空间名，用于Spring Bean的定义； xsi命名空间：这个命名空间用于为每个文档中命名空间指定相应的Schema样式文件，是标准组织定义的标准命名空间； aop命名空间：这个命名空间是Spring配置Aop的命名空间，是用户自定义的命名空间； 命名空间的定义分为两个步骤：第一步指定命名空间的名称，第二部指定命名空间Schema文档样式文件的位置，用空格或回车换行进行分割。在第二步中，指定命名空间的Schema文件地址有两个用途：XML解析器可以获取Schema文件并对文档进行格式合法性验证；在开发环境下，IDE可以引用Schema文件对文档编辑提供诱导功能。 2、Bean的基本配置2.1 Bean配置的基础知识一般情况下，Spring IoC容器中的一个Bean即对应配置文件中的一个&lt;bean&gt;，其中id为这个Bean的名称，通过容器的getBean(id)即可获取对应的Bean，在容器中起到定位查找的作用。class属性指定了Bean对应的实现类。1&lt;bean id="foo" class="com.hhxs.domain.Foo"&gt; id在IoC的容器中必须是唯一的，此外id的命名也需要满足XML对id的命名规范（id是XML规定的特殊属性）：必须以字母开始，后面可以是字母、数字、连字符、下划线、句号、冒号的完整结束的符号，逗号和空格这些非完整结束符是非法的。name属性没有字符上的限制，几乎可以使用任何字符。另外id和name都可以指定多个名字，名字之间用逗号、分号或者空格进行分隔：1&lt;bean name="foo,#foo,$foo" class="com.hhxs.domain.Foo"&gt; 可以使用getBean(“foo”)、getBean(“#foo”)、getBean(“$foo”)获取IoC容器中的Foo Bean。Spring配置文件中不允许出现两个相同id的&lt;bean&gt;，但可以出现两个相同name的&lt;bean&gt;，多个name相同的&lt;bean&gt;，通过getBean(beanName)获取Bean时，将返回最后声明的那个Bean。如果id和name两属性都未指定，如&lt;bean class=&quot;com.baobaotao.simple.Car&quot;&gt;，Spring自动将全限定类名作为Bean的名称。 2.2 注入方式Spring支持两种依赖注入方式，分别是属性注入和构造函数注入。除此之外，Spring还支持工厂方法注入方式。 2.2.1 属性注入属性注入是配置Bean之间的依赖关系最常用的一种方式，属性注入要求Bean提供一个默认的构造函数，并为需要注入的属性提供对应的Setter方法。Spring先调用Bean的默认构造函数实例化Bean对象，然后通过反射的方式调用Setter方法注入属性值。JavaBean的属性命名规范：xxx的属性对应setXxx()方法。一般情况下，Java的属性变量名都以小写字母起头，特殊情况下，也允许大写字母起头的属性变量名，但是必须满足“变量的前两个字母要么全部大写，要么全部小写”。下面看一个例子：12345678910111213141516171819202122232425public class Car &#123; private String brand; private String color; private int maxSpeed; public void setBrand(String brand) &#123; System.out.println("调用setBrand()设置属性。"); this.brand = brand; &#125; public void setColor(String color) &#123; this.color = color; &#125; public void setMaxSpeed(int maxSpeed) &#123; this.maxSpeed = maxSpeed; &#125; ......&#125;// Spring配置文件中的属性注入配置&lt;bean id="car" class="com.hhxs.bbt.web.Car" &gt; &lt;property name="brand"&gt;&lt;value&gt;红旗CA72&lt;/value&gt;&lt;/property&gt; &lt;property name="color"&gt;&lt;value&gt;红色&lt;/value&gt;&lt;/property&gt; &lt;property name="maxSpeed"&gt;&lt;value&gt;200&lt;/value&gt;&lt;/property&gt;&lt;/bean&gt; Bean的每一个属性对应一个标签，如maxSpeed对应setMaxSpeed()。 提示:默认构造函数是不带参的构造函数。Java语言规定如果类中没有定义任何构造函数，则JVM自动为其生成一个默认的构造函数。反之，如果类中显示定义了构造函数，则JVM不会为其生成默认的构造函数。 2.2.2 构造函数注入构造函数注入方式是除属性注入之外的另一种常用的注入方式，它保证一些必要的属性在Bean实例化时就得到设置，它保证了Bean实例在实例化后就可以使用。其中构造参数注入又分为，按类型匹配入参、按索引匹配入参、联合使用类型和索引匹配入参等。这是因为Java反射机制并不会记住构造函数的入参名，我们无法通过指定构造函数的入参名进行构造函数注入的配置，而只能通过入参类型和索引信息间接确定构造函数配置项和入参的对应关系。下面直接看一个联合使用类型和索引匹配入参的代码片段：123456789101112131415161718192021222324252627...public Car(String brand, String corp, double price) &#123; this.brand = brand; this.corp = corp; this.price = price;&#125;public Car(String brand, String corp, int maxSpeed) &#123; this.brand = brand; this.corp = corp; this.maxSpeed = maxSpeed;&#125;...// Spring配置文件中的配置&lt;!-- 对应Car(String brand, String corp, int maxSpeed)构造函数 --&gt;&lt;bean id="car" class="com.hhxs.bbt.web.Car" &gt; &lt;constructor-arg index="0" type="java.lang.String"&gt; &lt;value&gt;红旗CA72&lt;/value&gt; &lt;/constructor-arg&gt; &lt;constructor-arg index="1" type="java.lang.String"&gt; &lt;value&gt;中国一汽&lt;/value&gt; &lt;/constructor-arg&gt; &lt;constructor-arg index="2" type="int"&gt; &lt;value&gt;200&lt;/value&gt; &lt;/constructor-arg&gt;&lt;/bean&gt; 如果构造函数没有歧义的话，上面配置文件中的type属性和index属性均可去除。另外如果，Bean构造函数入参的类型是可辨别的（非基础数据类型且入参类型各异），构造函数注入的配置也是可以不提供类型和索引的信息，但是为了避免潜在配置歧义问题，如果Bean存在多个构造函数，使用显示指定index和type属性不失为一种良好的配置习惯。 2.2.3 工厂注入方法Spring IoC容器以框架的方式提供工厂方法的功能，并以透明的方式开放给开发者，所以很少需要手工编写基于工厂方法的类。正因为此，工作方法对于实际编码的重要性大大降低，它将慢慢地淡出开发人员的视野，这里不在说明。 2.2.4 注入方式的选择支持构造函数注入方式的理由： 构造函数可以保证一些重要的属性在Bean实例化时就设置好，避免因为一些重复属性没有提供，导致一个无用Bean实例的情况； 不需要为每个属性提供Setter方法，减少了类的方法个数； 可以更好地封装类变量，不需要为每个属性指定Setter方法，避免外部错误的调用。 支持属性注入方式的理由： 如果一个类的属性众多，构造函数的签名将变成一个庞然大物，可读性很差； 灵活性不够，在有些属性是可选的情况下，如果通过构造函数注入，也需要为可选的参数提供一个null值； 如果有多个构造函数，需要考虑配置文件和具体构造函数匹配歧义的问题，配置上相对复杂； 构造函数不利于类的继承和扩展，因为子类需要引用到父类复杂的构造函数； 构造函数注入有时会造成循环依赖的问题。 两种方式各有优缺点，生产环境中要根据实际情况使用。除了工厂方法的注入方式已不再使用，属性注入和构造函数注入方式都是比较常用的。 2.3 简化配置方式在之前的例子里我们采用完整配置格式的配置方式，也许你已经发现这种方式显得比较拖沓。如果系统中拥有大量的类需要配置，我们一定会感到崩溃。还好Spring为我们提供了简化的配置方式。如果没有用到完整配置格式的特殊功能，我们一般都只使用简化的配置方式。 字面值属性： 简化前 简化后 字面值属性 &lt;property name=&quot;maxSpeed&quot;&gt; &lt;value&gt;你好&lt;/value&gt; &lt;/property&gt; &lt;property name=&quot;maxSpeed&quot; value=&quot;200&quot;/&gt; 构造函数参数 &lt;constructor-arg type=&quot;java.lang.String&quot;&gt; &lt;value&gt;红旗CA72&lt;/value&gt; &lt;/constructor-arg&gt; &lt;constructor-arg type=&quot;java.lang.String&quot; value=&quot;红旗CA72&quot;/&gt; 集合元素 &lt;map&gt; &lt;entry&gt; &lt;key&gt;&lt;value&gt;AM&lt;/value&gt;&lt;/key&gt; &lt;value&gt;会见客户&lt;value&gt; &lt;/entry&gt; &lt;/map&gt; &lt;map&gt; &lt;entry key=&quot;AM&quot; value=&quot;会见客户&quot;/&gt; &lt;/map&gt; 引用对象属性： 简化前 简化后 字面值属性 &lt;property name=&quot;car&quot;&gt; &lt;ref bean=&quot;car&quot;&gt;&lt;/ref&gt; &lt;/property&gt; &lt;property name=&quot;car&quot; ref=&quot;car&quot;/&gt; 构造函数参数 &lt;constructor-arg&gt; &lt;ref bean=&quot;car&quot;/&gt; &lt;/constructor-arg&gt; &lt;constructor-arg ref=&quot;car&quot;/&gt; 集合元素 &lt;map&gt; &lt;entry&gt; &lt;key&gt;&lt;ref bean=&quot;keyBean&quot;/&gt;&lt;/key&gt; &lt;ref bean=&quot;valueBean&quot;/&gt; &lt;/entry&gt; &lt;/map&gt; &lt;map&gt; &lt;entry key-ref=&quot;keyBean&quot; value-ref=&quot;valueBean&quot;/&gt; &lt;/map&gt; 使用P命名空间：为了简化XML文件的配置，越来越多的XML文件采用属性而非子元素配置信息。Spring从2.5版本开始引入了一个新的p命名空间，可以通过&lt;bean&gt;元素属性的方式配置Bean的属性。 未采用P命名空间前：123456789101112131415&lt;?xml version="1.0" encoding="UTF-8" ?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-3.0.xsd"&gt; &lt;bean id="car" class="com.hhxs.bbt.web.Car" &gt; &lt;property name="brand" value="红旗CA72" /&gt; &lt;property name="color" value="红色" /&gt; &lt;property name="maxSpeed" value="200" /&gt; &lt;/bean&gt; &lt;bean id="boss" class="com.hhxs.bbt.web.Boss"&gt; &lt;property name="car" ref="car"/&gt; &lt;/bean&gt;&lt;/beans&gt; 采用P命名空间后：1234567891011121314&lt;?xml version="1.0" encoding="UTF-8" ?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:p="http://www.springframework.org/schema/p" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-3.0.xsd"&gt; &lt;bean id="car" class="com.hhxs.bbt.web.Car" p:brand="红旗CA72" p:color="红色" p:maxSpeed="200"/&gt; &lt;bean id="boss" class="com.hhxs.bbt.web.Boss" p:car-ref="car"/&gt;&lt;/beans&gt; 未采用p命名空间前&lt;bean&gt;使用&lt;property&gt;子元素配置Bean的属性，采用p命名空间后，采用&lt;bean&gt;的元素属性配置Bean的属性。 对于字面值属性，其格式为： p:&lt;属性名&gt;=&quot;xxx&quot; 对于引用对象的属性，其格式为：p:&lt;属性名&gt;-ref=“xxx” 由于p命名空间中的属性名是可变的，所以p命名空间没有对应的Scheam定义文件，也就不需要在xsi:schemaLocation中为p命名空间指定Schema定义文件。 3. 自动装配Spring IoC容器了解容器中所有Bean的配置信息，此外通过Java反射机制还可以获取已知实现你类的结构信息（如构造函数方法的结构、属性等信息）。掌握容器中所有Bean的这些信息后，Spring IoC容器就可以按照某种规则对容器中的Bean进行自动装配，而无须我们通过显示的方式进行配置。 &lt;bean&gt;元素提供了一个指定自动个装配类型的属性：autowire=”&lt;自动装配类型&gt;”。Spring提供了4种自动装配类型： 自动装配类型 说明 byName 根据名称进行自动匹配。假设Boss有一个名为car的属性，如果容器中刚好有一个名为car的Bean，Spring就会自动将其装配给Boss的car属性。 byType 根据类型进行自动匹配。假设Boss有一个car类型的属性，如果容器中刚好有一个car类型的Bean，Spring就会自动将其装配给Boss的这个属性。 constructor 与ByType类似，只不过它是针对构造函数注入而言的，如果Boss有一个构造函数，构造函数包含一个Car类型的入参，如果容器中有一个Car类型的Bean，则Spring将自动把这个Bean作为Boss构造函数的入参，如果容器中没有找到和构造函数入参匹配类型的Bean，Spring将抛出异常。 autodetect 根据Bean的自省机制决定采用byType还是constructor进行自动装配：如果Bean提供了默认的构造函数，则采用byType; 否则采用constructor &lt;beans&gt;元素标签中的default-autowire属性可以配置全局自动匹配，default-autowire属性的默认值为no，表示不启用自动装配，其他几个配置值为：byName、byType、constructor、autodetect，意义同上面的表格。注意：&lt;beans&gt;中定义的自动装配策略可以被&lt;bean&gt;的自动装配策略覆盖。 注意：自动装配机制在减轻配置工作量的同时也会造成配置文件中Bean之间关系不清晰的问题，生产使用时要根据实际项目情况。 4. 整合多个配置文件对于一个大型应用来说，可能有多个XML配置文件，在启动时，可以通过一个String数组指定这些配置文件。Spring还允许我们通过&lt;import&gt;将多个配置文件引入到一个文件中，进行配置文件的集成。如下，beans2.xml引入了beans1.xml配置文件：123&lt;import resource="classpath:beans1.xml"/&gt;&lt;bean id="boss1" class="com.hhsx.bbt.web.Boss" p:car-ref="car1"/&gt;&lt;bean id="boss2" class="com.hhxs.bbt.web.Boss" p:car-ref="car2"/&gt; 假设我们已经在beans1.xml中配置了car1和car2的Bean,通过&lt;import&gt;引入beans1.xml，beans2.xml就拥有了完整的配置信息。Spring容器仅需要通过beans2.xml就可以加载到所有的配置信息了。 5. Bean作用域在配置文件中定义Bean时，除了可以配置Bean的属性值以及相互之间的依赖关系，还可以定义Bean的作用域。 Bean的作用域类型： 类别 说明 singleton 在Spring IoC容器中仅存在一个Bean实例，Bean以单实例的方式存在 。在Spring中，Bean的默认作用域为singleton。如果不希望在容器启动时提前实例化Bean，可以通过lazy-init属性进行控制。 prototype 每次从容器中调用Bean时，都返回一个新的实例，即每次调用getBean()时，相当于执行new XxxBean()的操作 request 每次HTTP请求都会创建一个新的Bean。该作用域仅适用于WeApplicationContext环境。 session 同一个HTTP Session共享一个Bean，不同HTTP Session使用不同的Bean。该作用域仅适用于WeApplicationContext环境。 globalSession 同一个全局Session共享一个Bean， 一般用于Porlet应用环境。该作用域仅适用于WeApplicationContext环境。 使用方式是： scope=&quot;&lt;作用域类型&gt;&quot;]]></content>
      <categories>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>Bean</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring3.X学习笔记1-IoC容器概述]]></title>
    <url>%2F2017%2F10%2F28%2FSpring3.X%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B01-IoC%E5%AE%B9%E5%99%A8%E6%A6%82%E8%BF%B0%2F</url>
    <content type="text"><![CDATA[2017即将接近尾声，每当年末的时候总要检查下今年还有什么事情没做，结果却发现今年好像也没做多少事情😶。于是就想着把之前一直想梳理的Spring知识，趁着年末好好整理下。本系列笔记基于”Spring3.x企业应用开发实战“一书，说来惭愧，书买了好多年了也没认真的看一遍，于是就有了这个想法，算是2017年的最后给自己的一份交代。 在开始之前，先简要介绍下Spring吧！ Spring是分层的Java SE/EE应用一站式的轻量级开源框架，由Rod Johnson创建，以IoC和AOP为内核，提供了展现层Spring MVC和持久层Spring JDBC以及业务层事务管理等众多企业级应用技术，并以海纳百川的胸怀整合了开源世界里众多的企业级应用技术，逐渐成为使用最多的Java EE企业应用开发框架。 1、IoC概述1.1 IoC的概念IoC（控制反转：Inverse of Control）是一个重要的面向对象编程理论，Spring核心模块实现了IoC的功能。Spring中的其他模块，像AOP、声明式事务等功能都是建立在IoC的基础之上，它将类和类之间的依赖从代码中脱离出来，用配置的方式进行依赖关系描述，由IoC容器负责依赖类之间的创建、拼接、管理、获取等工作。一般来说IoC的概念有两种表示方式，一个叫控制反转，一个叫依赖注入。由于控制反转并不好理解，业界也曾进行广泛的讨论，最终软件界的泰斗级人物Martin Folwer提出了DI（依赖注入：Dependency Injection）的概念用以代替IoC。 控制反转：对于软件来说，即某一接口具体实现类的选择控制权从调用类中移除，转交给第三方决定。 依赖注入：调用类对某一接口实现类的依赖关系由第三方（容器或协作类）注入，以移除调用类对某一接口实现类的依赖。 上面两个概念第一次接触的时候，你会发现都不太好理解，那是因为还不清楚IoC的实现机制，随着对IoC了解的深入，你会发现依赖注入的概念直接明了。 1.2 IoC的类型从注入方法上看，主要可以划分为三种类型：构造函数注入、属性注入和接口注入。Spring支持构造函数注入和属性注入。 构造函数注入: 在构造函数注入中，我们通过调用类的构造函数，将接口实现类通过构造函数变量传入。 属性注入: 属性注入是指通过Setter方法完成调用类所需依赖的注入。 接口注入: 将调用类所有依赖注入的方法抽取到一个接口中，调用类通过实现该接口提供相应的注入方法。 由于通过接口注入需要额外声明一个接口，增加了类的数目，而且它的效果和属性注入并无本质区别，所以不提倡采用这种方式。 2、IoC的底层实现原理Spring的核心模块实现了IoC的功能，它通过配置文件或注解描述类和类之间的依赖关系，自动完成类的初始化和依赖注入的工作。让开发者们从底层实现类的实例化、依赖关系装配等工作中脱离出来，专注于更有意义的业务逻辑开发工作。这种“神奇”的力量归功于Java语言本身的类反射功能。 2.1 Java反射知识Java语言允许通过程序化的方式间接对Class的对象实例操作，Class文件由类装载器装载后，在JVM中将形成一份描述CLass结构的元信息对象，通过该元信息对象可以获知Class的结构信息：如构造函数、属性和方法等。Java允许用户借由这个Class相关的元信息对象间接调用Class对象的功能，这就为使用程序化方式操作Class对象开辟了途径。下面先看一个例子： 1234567891011121314151617181920212223242526272829303132333435363738394041424344public class Car &#123; private String brand; private String color; private int maxSpeed; public Car() &#123;&#125; public Car(String brand, String color, int maxSpeed) &#123; this.brand = brand; this.color = color; this.maxSpeed = maxSpeed; &#125; public void introduce() &#123; System.out.println("brand:" + brand + ";color:" + color + ";maxSpeed:" + maxSpeed); &#125; // 省略参数的getter/Setter方法&#125;public class ReflectTest &#123; public static Car initByDefaultConst() throws Throwable &#123; // 通过类装载器获取Car类对象 ClassLoader loader = Thread.currentThread().getContextClassLoader(); Class&lt;?&gt; clazz = loader.loadClass("com.hhxs.bbt.web.Car"); // 获取类的默认构造器对象并通过它实例化Car Constructor&lt;?&gt; cons = clazz.getDeclaredConstructor((Class[]) null); Car car = (Car) cons.newInstance(); // 通过反射方法设置属性 Method setBrand = clazz.getMethod("setBrand", String.class); setBrand.invoke(car, "红旗CA72"); Method setColor = clazz.getMethod("setColor", String.class); setColor.invoke(car, "黑色"); Method setMaxSpeed = clazz.getMethod("setMaxSpeed", int.class); setMaxSpeed.invoke(car, 200); return car; &#125; public static void main(String[] args) throws Throwable &#123; Car car1 = initByDefaultConst(); car1.introduce(); &#125;&#125; 通过查看运行结果，可以看到这和直接通过构造函数和方法调用类功能的效果是一致的，只不过前者是间接调用，后者是直接调用罢了。这说明我们完全可以通过编程方式调用Class的各项功能。如果我们将这些信息以一个配置文件的方式提供，就可以使用Java语言的反射功能编写一段通用代码对类似于Car的类进行实例化及功能调用操作了。有没有感觉这和上面提到的Spring框架的实现机制很相似，Spring正是基于Java语言自带的反射机制实现了IoC的功能。 下面简要介绍下上述例子用到得三个主要反射类，这些反射对象类在java.reflect包中定义: Constructor: 类的构造函数反射类，通过Class#getConstructors()方法可以获得类的所有构造函数反射对象数组。Constructor的一个主要方法是newInstance(Object[]… initargs)，通过该方法可以创建一个对象类的实例，相当new关键字。 Method: 类方法的反射类，通过Class#getDeclaredMethods()方法可以获取类的所有方法发射类对象数组Method[]。Method最主要的方法是invoke(Object obj, Objcet… args)，obj表示操作的目标对象，args为方法入参。 Field: 类的成员变量反射类，通过Class#getDeclaredFields()方法可以获取类的成员变量反射对象数组。Filed类最主要的方法是set(Object obj, Object value)，obj表示操作的目标对象，通过value为目标类对象的成员变量设置值。 此外，Java还为包提供了Package反射类，在JDK5.0中还未注解提供了AnnotatedElement反射类。总之，Java的反射体系保证了可以通过程序化的方式访问目标类中的所有元素，对于private或protected的成员变量和方法，只要JVM的安全机制允许，也可以通过反射进行调用setAccessible(boolean access)。 3、三个核心接口Spring通过一个配置文件描述Bean及Bean之间的依赖关系，利用Java语言的反射功能实例化Bean并建立Bean之间的依赖关系。Spring的IoC容器在完成这些底层工作的基础上，还提供了Bean实例缓存、声明周期管理、Bean实例代理、事件发布、资源装载等高级服务。 3.1 BeanFactoryBean工厂(com.springframework.beans.factory.BeanFactory)是Spring框架最核心的接口，它提供了高级IoC的配置机制。BeanFactory使管理不同不同类型的Java对象成为可能，一般称BeanFactory为IoC容器。BeanFactory是类的通用工厂，它可以创建并管理各种类的对象，Spring称这些被创建和管理的Java对象为Bean。Bean最主要的方法就是getBean(String beanName)，该方法从容器中返回特定名称的Bean。下面看一个小例子:1234567891011121314151617181920212223242526// spring文件&lt;?xml version="1.0" encoding="UTF-8" ?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:p="http://www.springframework.org/schema/p" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-3.0.xsd"&gt; &lt;bean id="car" class="com.hhxs.bbt.web.Car" p:brand="红旗CA72" p:color="黑色" p:maxSpeed="200" /&gt;&lt;/beans&gt;// JAVA代码public class BeanFactoryTest &#123; public static void main(String[] args) throws Throwable&#123; ResourcePatternResolver resolver = new PathMatchingResourcePatternResolver(); Resource res = resolver.getResource("classpath:spring/beans.xml"); System.out.println(res.getURL()); BeanFactory bf = new XmlBeanFactory(res); System.out.println("init BeanFactory."); Car car = bf.getBean("car",Car.class); System.out.println("car bean is ready for use!"); car.introduce(); &#125;&#125; 注意： 通过BeanFactory启动IoC容器时，并不会初始化配置文件中定义的Bean，初始化动作发生在第一次调用时。对于单实例的Bean来说，BeanFactory会缓存Bean实例，所以第二次使用getBean()获取Bean时将直接从IoC容器的缓存中获取Bean实例。Spring在DefaultSingletonBeanRegistry类中提供了一个用于缓存单实例Bean的缓存器，它是一个用HashMap实现的缓存器，单实例的Bean以beanName为键保存在这个HashMap中。 3.2 ApplicationContext应用上下文(com.springframework.context.ApplicationContext)建立在BeanFactory基础之上，提供了更多面向应用的功能，它提供了国际化支持和框架事件体系，更易于创建实际应用。一般称ApplicationContext为应用上下文或者Spring容器。 ApplicationContext的主要实现类是ClassPathXmlApplicationContext和FileSystemXmlApplicationContext，前者默认从类路径中加载配置文件，后者默认从文件系统中装载配置文件。 123ApplicationContext ctx = new ClassPathXmlApplicationContext("spring/beans.xml"); //或者ApplicationContext ctx = new FileSystemXmlApplicationContext("spring/beans.xml"); 在获取ApplicationContext实例后，就可以像BeanFactory一样调用getBean(beanName)返回Bean了。需要注意的是：ApplicationContext在初始化应用上下文时就实例化所有单实例的Bean。因此，相比BeanFactory，初始化时间也会相对较长些，不过之后的调用就不在有“第一次惩罚”的问题。 3.3 WebApplicationContextWebApplicationContext是专门为Web应用准备的，它允许应用从相对于Web根目录的路径中装载配置文件完成初始化工作。从WebApplicationContext中可以获得ServletContext的引用，整个Web应用上下文对象将作为属性放置到ServletContext中，以便Web应用环境可以访问Spring应用上下文。 WebApplicationContext的初始化方式和BeanFactory、ApplicationContext有所区别，因为WebApplicationContext需要ServletContext实例，也就是说它必须在拥有Web容器的前提下才能完成启动的工作。有过Web开发经验的读者都知道可以在web.xml中配置自启动的Servlet(spring3.0及以后版本中已经删除)或定义Web容器监听器（ServletContextListener），借助这两者中的任何一个都可以完成启动Spring Web应用上下文的工作。通过web容器监听器启动：web.xml 1234567891011&lt;context-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt; classpath:/spring/spring-context.xml &lt;/param-value&gt;&lt;/context-param&gt;&lt;!-- spring容器启动监听器 --&gt;&lt;listener&gt; &lt;listener-class&gt;org.springframework.web.context.ContextLoaderListener&lt;/listener-class&gt;&lt;/listener&gt; 4、Bean的生命周期4.1 BeanFactory中Bean的生命周期我们知道Web容器中的Servlet拥有明确的生命周期，Spring容器中的Bean也拥有相似的生命周期。我们可以从两个层面定义Bean的生命周期：第一个层面是Bean的作用范围；第二个层面是实例化Bean时所经历的一系列阶段。 当调用者通过getBean(beanName)向容器请求某一个Bean时，如果容器注册了org.springframework.beans.factory.config.InstantiationAwareBeanPostProcessor接口，在实例化Bean之前，将调用接口的postProcessBeforeInstantiation()方法; 根据配置情况调用Bean构造函数或工厂方法实例化Bean； 如果容器注册了InstantiationAwareBeanPostProcessor接口，在实例化Bean之后，调用该接口的postProcessAfterInstantiationn()方法，可以在这里对已经实例化的对象进行处理。 如果Bean配置了属性信息，容器在这一步着手将配置值设置到Bean对应的属性中，不过在设置每个属性值之前先调用InstantiationAwareBeanPostProcessor接口的postProcessPropertyValues()方法； 调用Bean的属性设置方法设置属性值； 如果Bean实现了org.springframework.beans.factory.BeanNameAware接口，将调用setBeanName()接口方法，将配置文件中该Bean对应的名称设置到Bean中； 如果Bean实现了org.springframework.bean.factory.BeanFactoryAware接口，将调用setBeanFactory()接口方法，将BeanFactory容器实例设置到Bean中； 如果BeanFactory装配了org.springframework.beans.factory.config.BeanPostProcessor后处理器，将调用BeanPostProcessor的Object postProcessBeforeInstantiation(Object bean, Stringn beanName)接口方法对Bean进行加工操作。其中入参bean是当前正在处理的Bean，而beanName是当前Bean的配置名，返回的对象为加工处理后的Bean。BeanPostProcessor在Spring框架中占有重要的地位，为容器提供duiBean进行后续架构处理的切入点，Spring容器所提供的各种“神奇功能”（如AOP，动态代理等）都通过BeanPostProcessor实施； 如果Bean实现了InitializingBean的接口，将调用该接口的afterPropertiesSet()方法； 如果在通过init-method属性定义了初始化方法，将执行这个方法； BeanPostProcessor后处理定义了两个方法：其一时postProcessBeforeInstantiation()在第8步调用；其二是Object postProcessAfterInstantiationn(Object bean, String beanName)方法，这个方法在此时调用，容器中再次获得对Bean进行加工处理的机会。 如果在中指定Bean的作用范围是scope=”prototype”，将Bean返回给调用者，调用者负责Bean后续生命的管理，Spring不再管理这个Bean的生命周期。如果作用范围设置为scope=“singleton”，则将Bean放入到Spring IoC容器的缓存池中，并将Bean引用返回给调用者，Spring继续对这些Bean进行后续的生命管理。 对于scope=“singleton”的Bean，当容器关闭时，将触发Spring对Bean的后续生命周期的管理工作，首先如果Bean实现了DisposableBean接口，则将调用接口的afterPropertiesSet()方法，可以在此编写释放资源、记录日志等操作。 对于scope=“singleton”的Bean，如果通过的destroy-method属性指定了Bean的销毁方法，Spring将执行Bean的这个方法，完成Bean资源的释放等操作。 Bean生命周期实例：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184public class Car implements BeanFactoryAware, BeanNameAware, InitializingBean, DisposableBean &#123; private String brand; private String color; private int maxSpeed; private BeanFactory beanFactory; private String beanName; public Car() &#123; System.out.println("调用Car()构造函数。"); &#125; public Car(String brand, String color, int maxSpeed) &#123; this.brand = brand; this.color = color; this.maxSpeed = maxSpeed; &#125; public void introduce() &#123; System.out.println("brand:" + brand + ";color:" + color + ";maxSpeed:" + maxSpeed); &#125; public String getBrand() &#123; return brand; &#125; public void setBrand(String brand) &#123; System.out.println("调用setBrand()设置属性。"); this.brand = brand; &#125; public String getColor() &#123; return color; &#125; public void setColor(String color) &#123; this.color = color; &#125; public int getMaxSpeed() &#123; return maxSpeed; &#125; public void setMaxSpeed(int maxSpeed) &#123; this.maxSpeed = maxSpeed; &#125; // 5 DisposableBean方法 @Override public void destroy() throws Exception &#123; System.out.println("调用DisposaleBean.destroy()。"); &#125; // 4 IntializingBean接口方法 @Override public void afterPropertiesSet() throws Exception &#123; System.out.println("调用IntializingBean.afterPropertiesSet()。"); &#125; // 3 BeanNameAware接口方法 @Override public void setBeanName(String name) &#123; System.out.println("调用BeanNameAware.setBeanName()。"); this.beanName = beanName; &#125; // 2 BeanFactoryAware接口方法 @Override public void setBeanFactory(BeanFactory beanFactory) throws BeansException &#123; System.out.println("调用BeanFactoryAware.setBeanFactory()。"); this.beanFactory = beanFactory; &#125; // 6 通过&lt;bean&gt;的init-method属性指定的初始化方法 public void myInit() &#123; System.out.println("调用init-method所指定的myInit()，将maxSpeed设置为240。"); this.maxSpeed = 240; &#125; // 7 通过&lt;bean&gt;的destroy-method属性指定的销毁方法 public void myDestroy() &#123; System.out.println("调用destroy-method所指定的myDestroy()。"); &#125;&#125;public class MyInstantiationAwareBeanPostProcessor extends InstantiationAwareBeanPostProcessorAdapter &#123; // 1 在实例化Bean前进行调用 public Object postProcessBeforeInitialization(Class beanClass, String beanName) throws BeansException &#123; // 1-1 仅对容器中Car Bean进行处理 if ("car".equals(beanName)) &#123; System.out.println("InstantiationAware BeanPostProcessor.postProcessBeforeInstantiation"); &#125; return null; &#125; // 2 在实例化Bean后调用 public boolean postProcessAfterInstantiation(Object bean, String beanName) &#123; // 2-1 仅对容器中Car Bean进行处理 if ("car".equals(beanName)) &#123; System.out.println("InstantiationAware BeanPostProcessor.postProcessAfterInstantiation"); &#125; return true; &#125; // 3 在设置某个属性时调用 public PropertyValues postProcessPropertyValues(PropertyValues pvs, PropertyDescriptor[] pds, Object bean, String beanName) throws BeansException &#123; // 3-1 仅对容器中Car Bean进行处理,还可以通过pdst入参进行过滤，仅对car的某个特定属性时进行处理 if("car".equals(beanName)) &#123; System.out.println("InstantiationAware AwareBeanPostProcessor.postProcessPropertyValues"); &#125; return pvs; &#125;&#125;public class MyBeanPostProcessor implements BeanPostProcessor &#123; @Override public Object postProcessBeforeInitialization(Object bean, String beanName) throws BeansException &#123; if(beanName.equals("car")) &#123; Car car = (Car)bean; if(car.getColor() == null) &#123; System.out.println("调用BeanPostProcessor.postProcessBeforeInitialization(),color为空，设置为默认黑色。"); car.setColor("黑色"); &#125; &#125; return bean; &#125; @Override public Object postProcessAfterInitialization(Object bean, String beanName) throws BeansException &#123; if(beanName.equals("car")) &#123; Car car = (Car)bean; if(car.getMaxSpeed() &gt;= 200) &#123; System.out.println("调用BeanPostProcessor.postProcess AfterInitialization(), 将maxSpeed调整为200。"); car.setMaxSpeed(200); &#125; &#125; return bean; &#125;&#125;**beans.xml**&lt;?xml version="1.0" encoding="UTF-8" ?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:p="http://www.springframework.org/schema/p" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-3.0.xsd"&gt; &lt;bean id="car" class="com.hhxs.bbt.web.Car" init-method="myInit" destroy-method="myDestroy" p:brand="红旗CA72" p:maxSpeed="200" scope="singleton" /&gt;&lt;/beans&gt;public class BeanLifeCycle &#123; private static void lifeCycleInBeanFactory() &#123; Resource res = new ClassPathResource("spring/beans.xml"); BeanFactory bf = new XmlBeanFactory(res); // 向容器中注册后处理器 ((ConfigurableBeanFactory)bf).addBeanPostProcessor(new MyBeanPostProcessor()); ((ConfigurableBeanFactory)bf).addBeanPostProcessor(new MyInstantiationAwareBeanPostProcessor()); // 第一次从容器中获取Car，将触发容器实例化该Bean,这将引发Bean生命周期方法的调用。 Car car1 = (Car)bf.getBean("car"); car1.introduce(); car1.setColor("红色"); car1.introduce(); // 第二次从容器中获取Car，直接从缓存池中获取 Car car2 = (Car)bf.getBean("car"); // 查看car1和car2是否指向同一引用 System.out.println("car1==car2:" + (car1==car2)); // 关闭容器 ((XmlBeanFactory)bf).destroySingletons(); &#125; public static void main(String[] args) &#123; lifeCycleInBeanFactory(); &#125;&#125; 运行上述代码，我们在控制台上得到以下输出信息，仔细观察，将发现它验证了我们前面所介绍的Bean生命周期过程。123456789101112131415调用Car()构造函数。InstantiationAware BeanPostProcessor.postProcessAfterInstantiationInstantiationAware AwareBeanPostProcessor.postProcessPropertyValues调用setBrand()设置属性。调用BeanNameAware.setBeanName()。调用BeanFactoryAware.setBeanFactory()。调用BeanPostProcessor.postProcessBeforeInitialization(),color为空，设置为默认黑色。调用IntializingBean.afterPropertiesSet()。调用init-method所指定的myInit()，将maxSpeed设置为240。调用BeanPostProcessor.postProcess AfterInitialization(), 将maxSpeed调整为200。brand:红旗CA72;color:黑色;maxSpeed:200brand:红旗CA72;color:红色;maxSpeed:200car1==car2:true调用DisposaleBean.destroy()。调用destroy-method所指定的myDestroy()。 4.2 ApplicationContext中Bean的生命周期Bean在应用上下文中的生命周期和BeanFactory中生命周期类似，不同的是，如果Bean实现org.springframework.context.ApplicationContextAware接口，会增加一个调用该接口方法setApplicationContext()的步骤。 此外，如果配置文件中声明了工作后处理器接口BeanFactoryPostProcessor的实现类，则应用上下文在装载配置文件之后初始化Bean实例之前将调用这些BeanFactoryPostProcessor对配置信息进行加工处理。工厂后处理器是容器级的，仅在应用上下文初始化时调用一次，其目的是完成一些配置文件的加工处理工作。 ApplicationContext和BeanFactory另一最大的不同之处在于：前者会利用Java反射机制自动识别出配置文件中定义的BeanPostProcessor、InstantiationAwareBeanPostProcessor和BeanFactoryPostProcessor，并自动将它们注册到应用上下文中；而后者需要在代码中拿你给通过手工调用addBeanPostProcessor()方法进行注册。这也是为什么在应用开发室，我们普遍使用ApplicationContext而很少使用BeanFactory的原因之一。]]></content>
      <categories>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>IoC</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Activiti工作流之项目中的使用]]></title>
    <url>%2F2017%2F10%2F19%2FActiviti%E5%B7%A5%E4%BD%9C%E6%B5%81%E5%AD%A6%E4%B9%A02%2F</url>
    <content type="text"><![CDATA[Activiti工作流特点的其中之一就是原生支持Spring。前一章节我们介绍了Activit工作流的基本概念，让大家对工作流知识有了一个大体的印象，这一节我们说下在项目中的使用。 1、Spring集成首先在Maven中将Spring集成包引入进来。12345&lt;dependency&gt; &lt;groupId&gt;org.activiti&lt;/groupId&gt; &lt;artifactId&gt;activiti-spring&lt;/artifactId&gt; &lt;version&gt;5.22.0&lt;&lt;/version&gt;&lt;/dependency&gt; 可以把流程引擎（ProcessEngine）作为一个普通的Springbean进行配置。类org.activiti.spring.ProcessEngineFactoryBean是集成的切入点,这个bean需要一个流程引擎配置来创建流程引擎。 1234567891011121314151617&lt;!-- activiti config --&gt;&lt;bean id="processEngineConfiguration" class="org.activiti.spring.SpringProcessEngineConfiguration"&gt; &lt;property name="databaseType" value="oracle" /&gt; &lt;property name="dataSource" ref="dataSource" /&gt; &lt;property name="transactionManager" ref="transactionManager" /&gt; &lt;property name="databaseSchemaUpdate" value="true" /&gt;&lt;/bean&gt;&lt;bean id="processEngine" class="org.activiti.spring.ProcessEngineFactoryBean"&gt; &lt;property name="processEngineConfiguration" ref="processEngineConfiguration" /&gt;&lt;/bean&gt;&lt;bean id="repositoryService" factory-bean="processEngine" factory-method="getRepositoryService" /&gt;&lt;bean id="runtimeService" factory-bean="processEngine" factory-method="getRuntimeService" /&gt;&lt;bean id="taskService" factory-bean="processEngine" factory-method="getTaskService" /&gt;&lt;bean id="historyService" factory-bean="processEngine" factory-method="getHistoryService" /&gt;&lt;bean id="managementService" factory-bean="processEngine" factory-method="getManagementService" /&gt;z 其中datasource是指项目中配置的数据源，transactionManager是指项目中配置的事务管理器配置。如下： 123456789101112131415161718192021222324252627282930313233343536373839&lt;!-- 数据源配置 --&gt;&lt;bean id="dataSource" class="com.alibaba.druid.pool.DruidDataSource" init-method="init" destroy-method="close"&gt; &lt;!-- 基本属性 url、user、password --&gt; &lt;property name="driverClassName" value="$&#123;jdbc.driver&#125;" /&gt; &lt;property name="url" value="$&#123;jdbc.url&#125;" /&gt; &lt;property name="username" value="$&#123;jdbc.username&#125;" /&gt; &lt;property name="password" value="$&#123;jdbc.password&#125;" /&gt; &lt;!-- 配置初始化大小、最小、最大 --&gt; &lt;property name="initialSize" value="$&#123;jdbc.pool.initialSize&#125;" /&gt; &lt;property name="minIdle" value="$&#123;jdbc.pool.minIdle&#125;" /&gt; &lt;property name="maxActive" value="$&#123;jdbc.pool.maxActive&#125;" /&gt; &lt;!-- 配置获取连接等待超时的时间 --&gt; &lt;property name="maxWait" value="60000" /&gt; &lt;!-- 配置间隔多久才进行一次检测，检测需要关闭的空闲连接，单位是毫秒 --&gt; &lt;property name="timeBetweenEvictionRunsMillis" value="30000" /&gt; &lt;!-- 配置一个连接在池中最小生存的时间，单位是毫秒 --&gt; &lt;property name="minEvictableIdleTimeMillis" value="300000" /&gt; &lt;property name="validationQuery" value="SELECT 'x' from dual" /&gt; &lt;property name="testWhileIdle" value="true" /&gt; &lt;property name="testOnBorrow" value="false" /&gt; &lt;property name="testOnReturn" value="false" /&gt; &lt;!-- 打开PSCache，并且指定每个连接上PSCache的大小（Oracle使用） --&gt; &lt;property name="poolPreparedStatements" value="true" /&gt; &lt;property name="maxPoolPreparedStatementPerConnectionSize"value="20" /&gt; &lt;!-- 配置监控统计拦截的filters，去掉后监控界面sql无法统计 --&gt; &lt;property name="filters" value="stat" /&gt;&lt;/bean&gt;&lt;!-- 事务管理器配置,单数据源事务 --&gt;&lt;bean id="transactionManager" class="org.springframework.jdbc.datasource.DataSourceTransactionManager"&gt; &lt;property name="dataSource" ref="dataSource" /&gt;&lt;/bean&gt; 至此，集成成功，像使用一般bean对象的方式使用Activit对象即可。 2、基础API介绍项目里用到的基本都是顺序流，没有用到网关，所以在这里不会介绍网关的东西，只介绍项目用到相关知识。 2.1 七项基本操作 设计流程图（各种组件，如连线、用户任务、网关） 流程定义增删改查 流程变量增删改查 启动流程定义 任务增删改查 完成任务 历史信息查询 上面列举了Activiti中用到的七项操作种类，每一种操作都有着对应的API，需要用到哪些API请查看官网文档，或者Google，这里不再赘述。 2.2 常用操作2.2.1 使用Eclipse开始流程设计Eclipse插件安装请参照Activiti工作流之基础概念介绍 鼠标选中要新建流程图的文件夹，点击右键，选择new-&gt;others-&gt;Activiti Diagram，即可新建一个图表。记得要把Eclipse切换到Activit视图，一个简单的流程图类似下图，只需要关注红框里的元件就可以了，如果复杂的就需要用到其它元件了，比如网关。可以自行拖拽试试，网上这部分操作知识很多，这里不再赘述。 2.2.1 工作流部署其中recourceClassPath表示工作流相对项目classpath下的路径，例如maven项目中src/main/resource下的”bpmn/HelloWorldProcess.bpmn“。resourceName表示你要部署工作流的名称，这个名称一般用来说明工作流的作用，比如“请假流程“。12345public Deployment deployProcess(String resourceClassPath, String resourceName) &#123; Deployment deployMent = repositoryService.createDeployment().name(resourceName) .addClasspathResource(resourceClassPath).deploy(); return deployMent;&#125; 每重复部署一次，act_re_deployment表中新增加的记录的ID值都会随之增大，相应流程启动的时候取得是最新的值，也就是最大的值。如果想避免重复部署，可以使用下面的方式：123456public Deployment deployProcess(String resourceClassPath, String resourceName) &#123; //过滤关键是为流程部署起一个名字`fileName`，没有名字不会过滤 Deployment deployMent = repositoryService.createDeployment().enableDuplicateFiltering().name(fileName) .name(resourceName).addClasspathResource(resourceClassPath).deploy(); return deployMent;&#125; 2.2.2 流程启动其中procDefkey表示流程定义key, businessKey表示业务key, processVariables表示流程执行过程中需要的变量。123456789public ProcessInstance startProcessInstance(String procDefKey, String businessKey, Map&lt;String, Object&gt; processVariables) &#123; // 根据流程定义KEY查询最新版本的流程定义 ProcessDefinitionEntity procDef = (ProcessDefinitionEntity) getProcessDefinitionByKey(procDefKey); if (procDef == null) &#123; throw new RuntimeException("流程定义KEY为" + procDefKey + "流程定义未找到，请重新发布"); &#125; return runtimeService.startProcessInstanceByKey(procDefKey, businessKey, processVariables);&#125; 2.2.3 任务完成其中taskId表示要完成的任务ID,variables表示流程变量123456private void commitProcess(String taskId, Map&lt;String, Object&gt; variables) &#123; if (variables == null) &#123; variables = new HashMap&lt;String, Object&gt;(); &#125; taskService.complete(taskId, variables); &#125; 2.2.4 流程跳转这里只说明主要算法，其中taskId表示任务ID，activityId表示待跳转的“活动节点Id”123456789101112131415161718private void commitProcess(String taskId, String activityId) &#123; // 当前节点 ActivityImpl currActivity = findActivitiImpl(taskId, null); // 清空当前流向 List&lt;PvmTransition&gt; oriPvmTransitionList = clearTransition(currActivity); // 创建新流向 TransitionImpl newTransition = currActivity.createOutgoingTransition(); // 目标节点 ActivityImpl pointActivity = findActivitiImpl(taskId, activityId); // 设置新流向的目标节点 newTransition.setDestination(pointActivity); // 提交任务 taskService.complete(taskId, variables); // 删除目标节点新流入 pointActivity.getIncomingTransitions().remove(newTransition); // 还原以前流向 restoreTransition(currActivity, oriPvmTransitionList); &#125; 2.2.4 流程终止其中procId表示流程实例ID12345678public void terminateByBillCode(String procId) &#123; try &#123; // 终止流程 runtimeService.deleteProcessInstance(procId, "删除原因"); &#125; catch (Throwable e) &#123; LOG.error("终止流程By业务单号-controller" + e.getMessage(), e); &#125;&#125; 2.2.5 工作流删除其中deploymentId表示工作流部署ID，这个方法一般很少使用，新工作流启动时会自动选择最新部署的工作流。如果工作流需要更新，只需要重新部署工作就即可。1234567public void deleteDeployment(String deploymentId) throws Exception &#123; RepositoryService repositoryService = processEngine.getRepositoryService(); // 普通删除，如果当前规则下有正在执行的流程，则抛出异常 //repositoryService.deleteDeployment(deploymentId); // 级联删除，会删除和当前规则相关的所有信息，正在执行的信息，也包括历史信息 repositoryService.deleteDeployment(deploymentId,true);&#125; 2.3 集成自己的用户管理系统Activiti自带的用户权限管理系统功能不够强大，而一般业务系统都有自己的用户管理平台，你可以选择以某种方式来同步两者之间的用户信息，也可以直接使用业务系统的用户管理平台作为工作流权限管理。下面说下思路： 新建一个中间表比如ACT_PROC_CONFIG,字段包括流程key/角色ID/组织ID/用户ID。 提供一个页面用于设置对每个工作流进行设置，分别将各环节的任务分配给某个部门中的某个角色的某些人员。这样就将自己的用户管理平台和Activiti工作流有效集成起来了。 针对工作流编写业务代码的时候，将ACT_PROC_CONFIG表融进来，比如判断某个用户是否有当前任务的处理权限，下一环节任务有哪些人员可以处理等。 2.4 流程定制一般情况下，工作流部署以后流程就是固定的。具体每个用户任务可以根据业务需要提前设置好相应的部门处理人员，这样当执行到某个用户任务的时候，自然会有满足条件的人员可以处理。但是也有特殊情况，比如走到某个用户任务的时候，要根据当前的实际工作来判断后面的流程还需不需要走，还需要哪些流程处理，哪些流程可以跳过，哪些流程我想指定某个人来处理，这就牵扯到流程定制的问题。而这些功能基本上都是需要结合流程变量自己编码实现的。需要根据实际的业务自行设计，主要就是用到了流程变量和流程跳转功能，业务不同设计也不同，这里也不再讲述，只是说明一种应用场景。 2.5、资源的自动部署Spring的集成也有一个专门用于对资源部署的特性。在流程引擎的配置中，你可以指定一组资源。当流程引擎被创建的时候， 所有在这里的资源都将会被自动扫描与部署。在这里有过滤以防止资源重新部署，只有当这个资源真正发生改变的时候，它才会向Activiti使用的数据库创建新的部署。 这对于很多用例来说，当Spring容器经常重启的情况下（例如 测试），使用它是非常不错的选择。这里有一个例子：12345678&lt;bean id="processEngineConfiguration" class="org.activiti.spring.SpringProcessEngineConfiguration"&gt; ... &lt;property name="deploymentResources" value="classpath*:/activiti/*.bpmn" /&gt;&lt;/bean&gt;&lt;bean id="processEngine" class="org.activiti.spring.ProcessEngineFactoryBean"&gt; &lt;property name="processEngineConfiguration" ref="processEngineConfiguration" /&gt;&lt;/bean&gt; 默认，上面的配置会把所有匹配的资Activiti引擎的一个单独发布包下。用来检测防止未修改资源重复发布的机制会作用到整个发布包中。 有时候，这可能不是你想要的。比如，如果你发布了很多流程资源，但是只修改里其中某一个单独的流程定义， 整个发布包都会被认为变更了，导致整个发布包下的所有流程定义都会被重新发布， 结果就是每个流程定义都生成了新版本，虽然其中只有一个流程发生了改变。 为了定制发布方式，你可以为SpringProcessEngineConfiguration指定一个额外的参数deploymentMode。 这个参数指定了匹配多个资源时的发布处理方式。默认下这个参数支持设置三个值： default: 把所有资源放在一个单独的发布包中，对这个发布包进行重复检测。 这是默认值，如果你没有指定参数值，就会使用它。 single-resource: 为每个单独的资源创建一个发布包，并对这些发布包进行重复检测。 你可以单独发布每个流程定义，并在修改流程定义后只创建一个新的流程定义版本。 resource-parent-folder: 把放在同一个上级目录下的资源发布在一个单独的发布包中，并对发布包进行重复检测。 当需要多资源需要创建发布包，但是需要根据共同的文件夹来组合一些资源时，可以使用它。 12345&lt;bean id="processEngineConfiguration" class="org.activiti.spring.SpringProcessEngineConfiguration"&gt; ... &lt;property name="deploymentResources" value="classpath*:/activiti/*.bpmn" /&gt; &lt;property name="deploymentMode" value="single-resource" /&gt;&lt;/bean&gt; 项目中虽然没用到工作流的网关等功能，但是因为项目中的流程定制业务较多，加上实际使用场景要考虑很多问题，实际使用时还是蛮复杂的。这还需要在实际项目中历练，才能更加清晰掌握工作流的使用。但是如果只是想要简单的入门，找几个例子学习下就可以了。]]></content>
      <categories>
        <category>Activiti工作流</category>
      </categories>
      <tags>
        <tag>Activiti</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Activiti工作流之基础概念介绍]]></title>
    <url>%2F2017%2F10%2F13%2FActiviti%E5%B7%A5%E4%BD%9C%E6%B5%81%E5%AD%A6%E4%B9%A01%2F</url>
    <content type="text"><![CDATA[自我驱动力的来源是刚需。 前段时间从另外一个团队手里接过来一个半成品项目，是一个工作流系统。半成品就算了，还要快速完成工作任务，说多了都是泪，算是接了一个大锅。为了快速上手Activiti工作流的使用，基本上是边学习变实践，因此整个项目做下来对工作流知识依然处于比较散乱的阶段，趁着项目暂时告一段落把知识梳理下。言归正传，下面进入正题： 1、基本概念 工作流：业务过程的部分或整体在计算机应用环境下的自动化 工作流管理系统：工作流的定义和管理，按照在系统中预定义好的工作流规则进行工作流实例的执行。 工作流管理系统的目标：管理工作流程以确保工作在正确的时间被期望的人员执行–在自动化进行的业务过程中插入人工的执行和干预。 Activiy是什么 Activiti是一个针对企业用户、开发人员、系统管理员的轻量级工作流业务管理平台，其核心是使用Java开发的快速、稳定的BPMN2.0流程引擎。 Activiti的特点 数据持久化，底层使用MyBatis 引擎Service接口 流程设计器 原生支持Spring 分离运行时与历史数据 2、核心表介绍2.1 理解数据库表的命名Activiti的表都以ACT_开头。第二部分表示表的用途的两个字母标识。用途也和服务的API对应。 ACTRE*:’RE’表示repository。这个前缀的表包含了流程定义和流程静态资源（图片、规则，等等） ACTRU*: ‘RU’表示rutime。这些运行时的表，包含流程实例、任务、变量、异步任务，等运行中的数据。Activiti只在流程实例执行过程中保存这些数据，在流程结束时就会删除这些记录。这样可以保证运行时表可以一直很小且速度很快。 ACTID*’ID’表示identity。这些表包含身份信息，比如用户，组等等。 ACTHI*:’HI’表示history。这些表包含历史数据，比如历史流程实例、变量、任务等等。 ACTGE*: 通用数据，用于不同场景下。 2.2 表用途介绍通用数据表: ACT_GE_BYTEARRAY: 存储部署流程的二进制数据，一个流程包括一个工作流信息和一张对应的工作流图片。ACT_GE_PROPERTY: 存储整个流程引擎级别的数据，用于部署流程时获取新的版本号，初始化表结构时，会默认插入三条记录 历史数据库表: ACT_HI_ACTINST: 存储历史活动节点数据ACT_HI_ATTACHMENT: 存储历史附件数据ACT_HI_COMMENT: 存储历史评论数据或者事件数据ACT_HI_DETAIL: 存储历史流程变量详情信息ACT_HI_IDENTITYLINK: 存储历史流程人员操作信息ACT_HI_PROCINST: 存储历史流程实例信息ACT_HI_TASKINST: 存储历史任务实例信息ACT_HI_VARINST: 存储历史流程变量信息 用户组织表: ACT_ID_GROUP: 存储用户组信息ACT_ID_INFO: 存储用户扩展信息ACT_ID_MEMBERSHIP: 存储用户与用户组队形信息ACT_ID_USER: 存储用户信息 工作流流程规则表: ACT_RE_DEPLOYMENT: 存储工作流部署信息，比如工作流名称等ACT_RE_MODEL: 存储流程设计模型信息ACT_RE_PROCDEF: 存储流程定义数据 运行时数据表: ACT_RU_EVENT_SUBSCR: 如果流程到达某个事件节点，Activiti会往该表中加入事件描述数据，这些事件描述数据将会决定流程事件的触发。ACT_RU_EXECUTION: 存储运行时流程执行实例信息ACT_RU_IDENTITYLINK: 存储运行时流程人员操作信息，主要存储任务节点与参与者的相关信息ACT_RU_JOB: 存储运行时定时任务信息ACT_RU_TASK: 存储运行时任务节点信息ACT_RU_VARIABLE: 存储运行时流程变量信息 其他: CT_EVT_LOG: 存储事件日志信息ACT_PROCDEF_INFO: 存储流程定义的动态变更信息 3、核心概念介绍3.1 核心API ProcessEngine: 在Activiti中最核心的类 ProcessDefinition: 流程定义类。可以从这里获得资源文件等。 ProcessInstance: 代表流程定义的执行实例，一个流程实例包括了所有的运行节点。我们可以利用这个对象来了解当前流程实例的进度等信息，一个流程实例就表示一个流程从刚开始到结束的最大流程分支，即一个流程中流程实例只有一个。 Execution: Activiti用这个对象去描述流程执行的每一个节点。在没有并发的条件下，Execution就是同ProcessInstance。流程按照流程定义的规则执行一次的过程，就可以表示执行对象Execution。 一个流程中，执行对象可以存在多个，但是流程实例只能有一个。 当流程按照规则只执行一次的时候，那么流程实例就是执行对象。 Task: 执行到某任务环节时生成的任务信息。 由于数据库中保存着历史信息以及正在运行的流程实例信息，在实际项目中对已完成任务的查看频率远不及对代办和可接任务的查看，所以在activiti采用分开管理，把正在运行的交给RuntimeService、TaskService管理，而历史数据交给HistoryService来管理。 流程变量: 在流程执行或者任务执行的过程中，用于设置和获取变量，使用流程变量在流程传递的过程中传递业务参数。 3.2 七大Service接口 RepositoryService: 仓库服务类，管理流程定义。用于管理流程仓库，例如部署、删除、读取流程资源。所谓的仓库指流程定义文档的两个文件：bpmn文件和流程图片。 IdentifyService: 身份Service，用户管理和查询用户、组之间的关系 RuntimeService: 流程执行服务类，可以从这个服务类中获取很多关于流程执行相关的信息。 TaskService: 任务服务类，可以从这个类中获取任务的信息。 FormService: 表单Servcie，用于读取流程、任务相关的表单数据。 HistoryService: 查询历史信息的类，在一个流程执行完成后，这个对象为我们提供查询历史信息，例如流程实例、任务、活动、变量、附件。 ManagementService引擎管理Service，和具体业务无关，主要可以查询引擎配置、数据库、作业等。 学习知识最好先对基础的概念有个初步的认识，这方便在后续的学习过程中更好的理解这些概念。在对Activiti有了初步的印象后，下面通过在使用的过程中进一步熟悉Activiti工作流。 4、开始使用Activiti默认使用自带的H2内存数据库，而实际生产环境中使用Oracle或mysql居多，这里配置为oracle数据库。 4.1 在项目里引入相关jar这里将Spring集成包也引入进来了，这是生产环境常用的使用方式。不需要的可以将activiti-spring引用包去掉。123456789101112131415&lt;dependency&gt; &lt;groupId&gt;org.activiti&lt;/groupId&gt; &lt;artifactId&gt;activiti-engine&lt;/artifactId&gt; &lt;version&gt;5.22.0&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.activiti&lt;/groupId&gt; &lt;artifactId&gt;activiti-spring&lt;/artifactId&gt; &lt;version&gt;5.22.0&lt;&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.slf4j&lt;/groupId&gt; &lt;artifactId&gt;slf4j-api&lt;/artifactId&gt; &lt;version&gt;1.7.6&lt;/version&gt;&lt;/dependency&gt; 4.2 安装Activiti数据库Activiti框架拥有自动建表功能，在创建流程引擎对象的时候会在数据库中自动创建表。 4.2.1 不使用配置文件测试代码：12345678910public void intiProcessEngine() &#123; // 获取流程引擎 ProcessEngine processEngine = new StandaloneProcessEngineConfiguration() .setJdbcUrl("jdbc:oracle:thin:@172.16.58.17:1521:orcl") .setJdbcUsername("activiti") .setJdbcPassword("111111") .setJdbcDriver("oracle.jdbc.driver.OracleDriver") .setDatabaseSchemaUpdate(ProcessEngineConfiguration.DB_SCHEMA_UPDATE_TRUE) .buildProcessEngine(); &#125; 4.2.2 使用activiti.cfg.xml配置文件在classpath下创建activiti.cfg.xml配置文件（名称随意，只要能访问到即可），内容如下：123456789101112131415161718192021222324252627282930313233&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:context="http://www.springframework.org/schema/context" xmlns:tx="http://www.springframework.org/schema/tx" xmlns:jee="http://www.springframework.org/schema/jee" xmlns:aop="http://www.springframework.org/schema/aop" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-3.0.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-3.0.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx-3.0.xsd http://www.springframework.org/schema/jee http://www.springframework.org/schema/jee/spring-jee-3.0.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop-3.0.xsd"&gt; &lt;!-- 配置流程引擎配置对象 --&gt; &lt;bean id="processEngineConfiguration" class="org.activiti.engine.impl.cfg.StandaloneProcessEngineConfiguration"&gt; &lt;property name="jdbcUrl" value="jdbc:oracle:thin:@172.16.58.17:1521:orcl"/&gt; &lt;property name="jdbcDriver" value="oracle.jdbc.driver.OracleDriver" /&gt; &lt;property name="jdbcUsername" value="activiti" /&gt; &lt;property name="jdbcPassword" value="111111" /&gt; &lt;property name="databaseSchemaUpdate" value="true" /&gt; &lt;property name="jobExecutorActivate" value="false" /&gt; &lt;/bean&gt; &lt;bean id="processEngine" class="org.activiti.spring.ProcessEngineFactoryBean"&gt; &lt;property name="processEngineConfiguration" ref="processEngineConfiguration" /&gt; &lt;/bean&gt; &lt;bean id="repositoryService" factory-bean="processEngine" factory-method="getRepositoryService" /&gt; &lt;bean id="runtimeService" factory-bean="processEngine" factory-method="getRuntimeService" /&gt; &lt;bean id="taskService" factory-bean="processEngine" factory-method="getTaskService" /&gt; &lt;bean id="formService" factory-bean="processEngine" factory-method="getFormService" /&gt; &lt;bean id="historyService" factory-bean="processEngine" factory-method="getHistoryService" /&gt; &lt;bean id="managementService" factory-bean="processEngine" factory-method="getManagementService" /&gt; &lt;bean id="identityService" factory-bean="processEngine" factory-method="getIdentityService" /&gt;&lt;/beans&gt; 测试代码：12345public void intiProcessEngine() &#123; // 获取流程引擎 ProcessEngineConfiguration pec = ProcessEngineConfiguration.createProcessEngineConfigurationFromResource("activiti.cfg.xml"); processEngine = pec.buildProcessEngine();&#125; 4.2.3 使用默认配置文件配置文件要求配置文件名称必须为activiti-context.xml或者activiti.cfg.xml因为,因为默认的配置ProcessEngines.getDefaultProcessEngine();会初始化这两个文件的其中一个. 测试代码：123public void intiProcessEngine() &#123; ProcessEngine processEngine =ProcessEngines.getDefaultProcessEngine();&#125; 4.3 开发环境搭建|Eclipse插件安装 通过网址：[https://www.activiti.org/designer/archived/activiti-designer-5.18.0.zip] 下载离线安装包。 将离线安装包解压缩，将包中的内容放入eclipse根目录的dropins文件夹下，重启eclipse。 安装成功后，打开菜单Preferences-&gt;Activiti-&gt;Save Action，勾选流程图片的生成方式为当保存流程设计图时。]]></content>
      <categories>
        <category>Activiti工作流</category>
      </categories>
      <tags>
        <tag>Activiti</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用Hexo在Github上搭建个人Blog]]></title>
    <url>%2F2017%2F09%2F21%2F%E4%BD%BF%E7%94%A8Hexo%E5%9C%A8Github%E4%B8%8A%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E7%BD%91%E7%AB%99%2F</url>
    <content type="text"><![CDATA[亲手创造的东西总会带给自己无以言表的喜悦，而且也会让你更加珍惜。想知道这个博客是怎么来的吗？下面就给大家展示下这个博客的创建过程。 在开始之前，你必须要有一个Github账号,如果还没有请去官网注册Github。另外，确认本地已经安装好git和npm,如果没有请访问Hexo官网，官网上有对Hexo安装及使用的详细介绍，包括git和npm的安装指导。这里只介绍Blog搭建过程。 1.Github PagesGithub Pages是一个静态站点托管服务，可以把Github repository里的个人站点页面直接托管到上面。 在浏览器中登录 Github，创建一个Repo，名称格式为yourname.github.io（注意必须要以github.io结尾） 2.安装Hexo再确认本地安装了git和npm后，Terminal里输入：12npm install -g hexonpm install -g hexo-cli 3.初始化本地站点123hexo init &lt;folder&gt;cd &lt;folder&gt;npm instll &lt;folder&gt;是你建立的文件夹名称，我这里是zqhao.github.io 继续在Terminal里执行12hexo generatehexo server hexo server 开启本地服务，浏览器中敲入http://localhost:4000/ 看看网站初始的样子。 4.关联GithubTerminal cd到&lt;folder&gt;下，使用vim命令打开_config.yml，我这里使用的Atom编辑器。找到deploy那一部分，改成：123deploy： type: git repo: https://github.com/yourname/yourname.github.io.git 其中：yourname，改成你的Github用户名，repo对应的地址在第1步建仓库的地方获取。 注意：在配置所有的_config.yml文件时，在所有的冒号:后边都要加一个空格，否则执行hexo命令会报错 5.部署到Github上12hexo generatehexo deploy 如过之前未关联过Github，执行hexo deploy的时候会提示你输入用户名密码，执行成功后，浏览器中敲打地址http://yourname.github.io， yourname是你自己的Github用户名。 6.使用Markdown书写文章并发布 Markdown是一种简化版的文字标记方式，被设计用来作为一种网络内容的写作用语言。你的yourname.github.io站点上的文章，就需要用这种语言。 Terminal里cd到&lt;folder&gt;下执行： 1hexo new &quot;filename&quot; 名为filename.md的文件会建在目录&lt;forder&gt;/soruce/_posts下，当然你也可以直接用编辑器在此文件夹下直接新建文件，比如Atom。 Terminal里执行： 12hexo ghexo d 以后你想发表博客文章的时候，无非就是在_posts目录中创建新的 .md 文件，而后 hexo generate，之后再 hexo deploy. Markdown语法很少，官网的教程通俗易懂，这里就不贴出来了，请直接进入官网学习Markdown ，尤其是Github Flavored Markdown。 至此网站初步搭建成功，但是正如你所看到的，网站很简约，使用也不是很方便，而且网站里什么都没有，下面我们对网站做些定制，以便让它好看些。当然，这些工作可以闲暇时间慢慢搞，慢慢来，耐心一点。 7.添加ssh key到Github7.1 生成ssh keyTerminal执行如下命令生成rsa key pair,注意“”中的地址换成你自己的，是注册Gtihup的邮箱地址。 $ ssh-keygen -t rsa -C “hzqiangmac@gmail.com” 执行完后会在路径~/.ssh下生成id_rsa和id_rsa.pub两个文件。 7.2 将ssh key添加到Github中打开~/.ssh/id_rsa.pub文件，里面的信息即为SSH key,将信息全部复制，粘贴到Github的Add SSH key页面。1Github--&gt;Settings--&gt;SSH and GPG keys--&gt;New SSH key Title标题随便起个名字，我的名字就是网站的名字zqhao.github.io,将上面复制的内容粘贴到key里，保存即可。 8.绑定个人域名此博客目前使用的域名是Github提供的二级域名，你也可以绑定为自己的个性域名。我是在阿里万网购买的域名，并且可直接在其网站上做域名解析。做过你会发现，很多事情并没有你想象的那么复杂，如果你没有尝试过这件事，鼓励你试着做一下。域名购买成功后，需要实名认证，国家要求必须要实名认证。 8.1添加CNAME文件在博客根目录下&lt;forder&gt;/source文件夹下新建CNAME文件，注意没有后缀，在里面添加你购买的域名信息，保存。Terminal里cd到&lt;forder&gt;目录下执行如下命令，重新部署网站，以后每次发布网站都需要执行一遍该命令：12hexo ghexo d 如果需要清空本地缓存，执行hexo clean,这里使用的hexo g和hexo d是第5部两个命令的缩写形式。 8.2给Github项目添加在项目的Settings中，在Custom domain中添加自己的域名： 8.3域名解析登录万网，在你购买的域名后边点击：解析 –&gt; 添加解析123记录类型：CNAME主机记录：填写@或者不填写记录值：yourname.github.io. (不要忘记最后的`.`) 保存之后，可能需要等一段时间才能生效,浏览器中敲入你购买的域名,ok！结束。 9.安装主题themeHexo官网主题里有很多主题，去上面找到自己喜欢的theme。我在搭建这个博客的时候，网上找的是hexo-theme-next，安装步骤很简单，直接去官网上看吧，因为你还需要定制很多东西，所以尽情DIY吧！ 到目前为止，算是大功告成了，后面要把精力放在使用Markdown写作上面，多写写有用的东西放在上面，这样你的这个网站才是有价值的，如果没有什么好的编辑器，这里推荐Atom编辑器，别问我问什么推荐这个，用用你就知道了，最重要的是适合自己。]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Git与Github]]></title>
    <url>%2F2017%2F09%2F19%2FGit%E4%B8%8EGithub%2F</url>
    <content type="text"><![CDATA[大学的时候就听说过Github,知道很多程序员都在使用Github，更是有很多大神在上面，不能说使用Github的才是优秀的程序员，但是有一点可以明确的是，github是程序员世界的社交平台，大家用彼此的语言高效交流，这是一种生活方式，而想要成为某个领域的高手，最好的方式就是按照高手的方式去生活，在他们的聚集地生活。 一直以来都没怎么好好认真做过一件事，所以接下来的两年里，我想把所有自己未曾做过的，对自己成长有帮助的事情做一遍，为了找回那丢失已久的自信，也为了给自己一个交代。好了，言归正传。 1.基础概念什么是Git Git是一个免费开源的分布式版本控制系统，被设计用于快速和高效处理任何项目。Git很容易学习且有着闪电般的性能。 什么是Github Github是一个基于web的Git版本控制仓库和Internet托管服务，主要用于代码。它提供了Git所有的分布式版本控制和源代码管理（功能），并添加了自己的特性。它为每个项目提供了访问控制和一些协作特性，例如bug跟踪、特性请求、任务管理等。 2.基本用法了解了要学习的东西是什么后，那么下面就开始学习基本的用法： Git在官网上有一个特别好的入门教程，大家可以访问网站上学习，30分钟足够入门，这是要用一辈子的事情。值得花时间好好学习下：https://try.github.io/levels/1/challenges/1 。在此不再多说，英文介绍不难理解，需要的话借助辞典。下面只对一些基础概念做些解释： staged: 表示文件处于已暂存的可以提交的状态。 unstaged:表示文件的改变还未暂存，当前状态下不可以提交。 untracked: 文件不在Git的管理中，这通常代表此文件是一个新文件。 deleted: 文件在本地已经删除正等待从Git上删除。 Staging Area: 可以理解为存放文件的地方（提交给Git仓库之前）。 Commit: “commit”命令可以视作仓库的快照，通过这种方式我们可以查看曾经做过对文件的所有改变，不管是自己还是别人操作的，它就像一个时间线一样，记录了所有的改变。 git remote: 将本地仓库上传到远程仓库，真正实现互联网协作。 git stash: 隐藏你自己的更改，git stash apply应用你的更改，一般用于拉取别人push的代码的时候。 当然一次学习不可能立马就能记住这些命令，很可能第一次正确理解这些概念都很难，不过没关系，这并不影响我们继续向前，在以后不断的实践的过程中你会慢慢理解这些概念的。 Github官网上也有个入门的教程Hello world，好的工具都是功能强大、简单易学的，所以请继续实践，这次15钟左右。。https://guides.github.com/activities/hello-world/。 同样下面只介绍概念： 学习一样知识或技能，首先就要掌握常用的概念，刚开始看不懂没关系，随着学习的继续深入，反复回过头来看，不断思考直至理解。这就像看书一样，会随着往后看的过程中，慢慢开始理解前面不太明白的地方。 respository: 仓库通常用于组织一个工程，可以包含任何你需要的东西，你的想法、资源甚至可以在上面与其他人分享和讨论。 branch: 分支可以让你在同一时间拥有同一仓库的不同版本，每个respository都有一个默认分支master，一般作为主分支。在Github中，branch一般用来修复bug和做些。分支是Git的核心概念，整个Github流就是基于此实现。未来的工作，当完成这些工作后，就会将子分支合并到主分支里。 pull request: 拉请求是在Github上协作的核心，当你打开一个拉请求，你提交你的改变并要求其他人查看你提交的东西并将它们合并到他们的分支中。拉请求显示了来自两个分支的内容的差异和不同。 在这里简单介绍下在Github里想要贡献自己代码的流程，方便大家理解pull requet： 1.fork别人的仓库，相当于拷贝一份别人的代码，然后clone到本地分支2.做些bug修复或添加新功能，然后发起pull request给原仓库作者，让他看到你的修改3.原仓库作者review这些改变，如果是正确的，他就会将你的这些改变merge到他自己的分支中 至此，整个pull request的过程结束，这也是在Github上与其他人协作的核心流程。 3.其他 习得任何技能的最根本技巧就是马上开始像那些已经精通这个技能的人一样生活. 所以请经常使用Github，没事的时候也在上面逛逛，也许就有收获。]]></content>
      <categories>
        <category>Git</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[写在开始]]></title>
    <url>%2F2017%2F09%2F06%2F%E5%86%99%E5%9C%A8%E5%BC%80%E5%A7%8B%2F</url>
    <content type="text"><![CDATA[曾经想，有台电脑就开始好好写作，有双运动鞋就开始好好跑步……于是一天一天就这么拖着，因为没电脑没好的运动鞋，所以没开始行动。将假设的前提没实现，当做自己不行动的的理由。我想生活应该是，哪怕残缺，也应该即刻开始出发，一步步变成自己理想的样子。]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>初心</tag>
      </tags>
  </entry>
</search>
